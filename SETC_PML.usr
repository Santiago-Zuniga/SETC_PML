c- constants -----------------------------------------------------------
#define RITAU uparam(1)               /* Ri_tau */
#define RITAU2 uparam(2)              /* Ri_tau2 (downstream from the break in slope) */
#define UTARGET uparam(3)             /* u_target for top PML, positive */ 
#define VISCFAC uparam(4)             /* viscosity multiplier at ouflow */
#define restart_inflow uparam(5)      /* whether to read inflow2d.ini (2d) for restasting */
#define restart_means uparam(6)       /* whether to read means.ini for means restasting */
#define iostep_2d_avg_time  uparam(7) /* output frequency for spanwise-time-averaged statistics */
#define iostep_2d_notime uparam(8)    /*output frequency for spanwise-averaged statistics*/
#define iostep_inflow param(15)       /* frequency of output for inflow2d file */
#define RE_TAU (1/param(2))           /* Re_tau */
c - mesh and buffer zones dimensions
#define PI (4.*atan(1.))
#define XLEN (8.0*PI/3.0)
#define YLEN uparam(9)
#define ZLEN (uparam(10)*PI)
#define ZBUFF (ZLEN-PI)
#define YBUFF 12.
#define NUMBER_ELEMENTS_X lelx
#define NUMBER_ELEMENTS_Y lely
#define NUMBER_ELEMENTS_Z lelz

c - Iflow dimensions
#define nelxin 8 /*number of elements of inflow array */
#define nelyin 4
#define nelzin 14
#define zlen_inflow (8.*PI)
#define hf 2.0 /*height of inflow domain*/
#define nelyint 13


      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     TURBULENT OUTFLOW
c     Sets low Re number in range [zout;lenz]
      real zout,zdiff
       
      zout = ZLEN-PI                               !<----------CHANGE!
      zdiff=ZLEN-zout
      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)
         if (z.ge.zout)then
               udiff =((param(2)*VISCFAC-param(2))/zdiff)
     $            *(z-zout) + param(2)
         endif
      else if(ifield.eq.2)then                    ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (z.ge.zout) then
          udiff =((param(8)*VISCFAC - param(8))/zdiff)
     $           *(z-zout) + param(8)
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz


      real*8 egrav(3)
C     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lz1,lely,lelz)
C 
      integer ex,ey,ez

c     BUFFER ZONE VARIABLES
      real*8 sigma2(3),sigmam1(3),sigmam2(3),beta,ybuff  !changed sigma to sigma2
     $        ,zbuff,umean1(3),umean2(3),yy,zz,m,vzout
      integer if_pml
      save if_pml

      if (istep.eq.0)then
       if (UTARGET.lt.0.)then
        if_pml=0
       else
        if_pml=1
       endif
      endif

c     MESH VARIABLES 
      egrav(1) = 0.0                         !x: Spanwise direction
      egrav(2) = -1.0*sqrt(1+RITAU**2)       !y: Wall-normal direction
      egrav(3) = 0.0                         !z: Streamwise direction

c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
      call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
      ffx = temp*egrav(1)
      ffy = (temp - tempbar(iy,iz,ey,ez))*egrav(2)
C       ffy = temp*egrav(2)
      ffz = temp*egrav(3)
c     ############################################################
c     ############################################################

c     ############################################################
c     ############################################################
      if (if_pml.eq.1)then
c     Buffer zones
        sigmam1(1) = 0.0                          !<-----------------CHANGE!
        sigmam1(2) = 1.0                          !<-----------------CHANGE!
        sigmam1(3) = 0.0                          !<-----------------CHANGE!

        sigmam2(1) = 0.0                          !<-----------------CHANGE!
        sigmam2(2) = 0.0                          !<-----------------CHANGE!
        sigmam2(3) = 0.0                          !<-----------------CHANGE!

        beta = 2.0                                !<-----------------CHANGE!

        umean1(1) = 0.0                           !<-----------------CHANGE! 
        umean1(2) =-UTARGET                       
        umean1(3) = 0.0                           !<-----------------CHANGE! 
        
        umean2(1) = 0.0                           !<-----------------CHANGE! 
        umean2(2) = 0.0                           !<-----------------CHANGE! 
        umean2(3) = 0.0                           !<-----------------CHANGE! 

        m=(YLEN-YBUFF)/(ZLEN
     &    -ZBUFF)
        zz = (y-YBUFF)/m + ZBUFF
        yy = m * (z-ZBUFF) + YBUFF

c     ###############
c     Top buffer zone
        sigma2(1) = 0.0
        sigma2(2) = 0.0
        sigma2(3) = 0.0
        if (y.ge.YBUFF.and.z.le.zz) then
          sigma2(1) = sigmam1(1)*((y - YBUFF)/(YLEN-YBUFF))**(beta)
          sigma2(2) = sigmam1(2)*((y - YBUFF)/(YLEN-YBUFF))**(beta)
          sigma2(3) = sigmam1(3)*((y - YBUFF)/(YLEN-YBUFF))**(beta)

          ffx = ffx - sigma2(1) * (ux - umean1(1))
          ffy = ffy - sigma2(2) * (uy - umean1(2)) 
          ffz = ffz - sigma2(3) * (uz - umean1(3))
        endif
c     ###################
c     Outflow buffer zone
C       if(.FALSE.) then
C           sigma2(1) = 0.0
C           sigma2(2) = 0.0
C           sigma2(3) = 0.0
C           call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
C           vzout = vzout_pl(ix,iy,ex,ey)
C           if (z.ge.ZBUFF.and.y.lt.yy.and.vzout.lt.0.0) then
C             sigma2(1) = sigmam2(1)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)
C             sigma2(2) = sigmam2(2)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)
C             sigma2(3) = sigmam2(3)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)

C             ffx = ffx - sigma2(1) * (ux - umean2(1))
C             ffy = ffy - sigma2(2) * (uy - umean2(2))
C             ffz = ffz - sigma2(3) * (uz - umean2(3))
C           endif
C       endif
c     ####################
      endif


      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)
 
      qvol   = 0.0
      source = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

c     ############################################################
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
      integer nelin,nel_slab,nin
      real rlenz,z_inflow,dz_inflow
      real dtimestep
      integer set_IC_flag

c     If set_IC_flag.eq.1 copy inflow file at bottom of big domain
      parameter(set_IC_flag=1)                           !<----- CHANGE!

      parameter(nelin=nelxin*nelyin*nelzin)
      parameter(nel_slab=nelxin*nelyin)
      parameter(nin = nelin*lx1*ly1*lz1)

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)
      save z_inflow

c     ############################################################
c     DEPTH-AVERAGED STATISTICS VARIABLES

c     Output frequency of span-time-averaged .fld files
c     and means.* binary files

c     Output frequency of span-averaged .fld files
C       integer iostep_2d
C       parameter( iostep_2d= 1000 )          !<-----------CHANGE!

c     Integration filter: The moments of velocity and concentration
c     are computed from z=0 to z=z_delta_fltr where z_delta_fltr
c     is the wall-normal location where we find a concentration
c     c<=delta_fltr


      real timem,atimem,timelm,dtimem,t_tot

c     spanwise-averaged arrays
      real    yavgx(ny1,nz1,lely,lelz)
     $    ,   zavgx(ny1,nz1,lely,lelz)

      parameter(nstat=38)
      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
c      save ravg, stat, stat2d
c      save rumm,rux2,ruvm,ruxm,rux2,summ,sux2,suvm,suxm,sux2,
c     &     summ_2d,sux2_2d,suvm_2d,suxm_2d,sux2_2d   !not necessary in a common block

      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)

      logical ifverbose
      real   wo1(lx1,ly1,lz1,lelv)
     &      ,  wo2(lx1,ly1,lz1,lelv)
     

      real             w1(ly1,lz1,lely,lelz)
     &              ,  w2(ly1,lz1,lely,lelz)
     &              ,  w3(ly1,lz1,lely,lelz)
     &              ,  w4(ly1,lz1,lely,lelz)
      save igs_x, igs_z

c     2d spanwise-averaged arrays 
      real v2d(ly1,lz1,lely,lelz),w2d(ly1,lz1,lely,lelz),
     &     y2d(ly1,lz1,lely,lelz),z2d(ly1,lz1,lely,lelz),
     &     tt2d(ly1,lz1,lely,lelz)


c     depth-averaged arrays
      real zavgxy(nz1,lelz)

c     dWh/dz (from cons. of mass dUh/dz=we)
      real    dzwavgxy(nz1,lelz),
     $        dzwavgxy_fltr(nz1,lelz)
c
c     Interface position array (intr) and threshold delta
      real intr(nz1,lelz)

c     average in time variables
      integer icalled
      save    icalled
      data    icalled /0/

      real atime,timel
      save atime,timel
      real alpha,beta
      integer n,nt

      integer icnt_time
      save    icnt_time
      data    icnt_time /0/

      integer icnt
      save    icnt
      data    icnt /0/
c
      character*32 istepc,outfile

      character*80 icfile
c
c     Gradient arrays for shear velocity, 
c     tke production and dissipation computation
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vyx(lx1,ly1,lz1,lelv),
     $     vyy(lx1,ly1,lz1,lelv),
     $     vyz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv),
     $     tx(lx1,ly1,lz1,lelv),
     $     ty(lx1,ly1,lz1,lelv),
     $     tz(lx1,ly1,lz1,lelv)

c     ############################################################
C       parameter(INTP_NMAX=ly1*lz1*lely*lelz)
      parameter(mz=lz1*lelz*3)
      parameter(myint=ly1*lely*3)
      parameter(INTP_NMAX=mz*myint)

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h, intp_h2
      save    nint, intp_h, intp_h2

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      real wintr(INTP_NMAX)
      save wintr
      real ymm(ly1,lz1,lely,lelz)
      save ymm
      real deltaz ,zdum
      save deltaz,zdum
      real  wintr3(myint), wintr2(myint)
      save wintr3,wintr2
      real y_inter(myint), tline(myint)
      save y_inter,tline
c     ############################################################
c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lz1,lely,lelz)
      


      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z
      n=nx1*ny1*nz1*nelv  
      nt=nx1*ny1*nz1*nelt
      m=ny1*nz1*nely*nelz
c     Restore geometry after loading the IC 
      if (istep.eq.0) then
       call opcopy(xm1,ym1,zm1,xmo,ymo,zmo)  ! Restore my geometry
       call geom_reset(1)                    ! Force regen. of Jacobians 
      endif

c
cc     ############################################################
cc     BUFFER REGION VARIABLES (by JS, has not been modified)
c      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)
c      real vzout_pldum(lx1,ly1,lelx,lely)
c      integer ex,ey,ez,eg
c      integer iostep_outflow,iostep_outflow_notime
c      real vmax,vmaxdum,zmax,wmin,wmindum,ymin
c
cc     Output frequency of outflow boundaries statistics    
c      parameter(iostep_outflow = 1000)               !<----- CHANGE!
c      parameter(iostep_outflow_notime = 1000)        !<----- CHANGE!
cc     ############################################################

c     ############################################################
c
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
c
c     This code is made for a mesh composed of only one box.
c     Computes the inlet boundary condition for the next time step
c     interpolating the solution for a TC with fixed mean 
c     streamwise velocity and concentration

      dtimestep = abs(dt)
c     READ INFLOW
      if (istep.eq.0) then
        call read_inflow(vxin,vyin,vzin,tin,nelin,nin)
        if (set_IC_flag.eq.1) then
          call set_IC(vxin,vyin,vzin,tin,nelin,nelxin,nelyin,nelzin
     $               ,nel_slab)
        endif
      endif

      call interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow
     $          ,zlen_inflow,dtimestep,int(restart_inflow))
      if (mod(istep,int(iostep_inflow)).eq.0) then
        call output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl,nel_slab
     $                       ,z_inflow)
      endif

c     ############################################################
c     OUTPUT INITIAL CONDITION
      if (istep.eq.0) then
        ifxyo = .true.
        call prepost(.true.,'   ' )
        ifxyo = .false.
        call print_yz_mesh
      endif

c     ############################################################
      if (istep.eq.0) then 
        call x_slice(ymm,ym1,w1,w2)
      endif
      if(icalled.eq.0) then
        call rzero(rumm,size(rumm))
        call rzero(ru2m,size(ru2m))
        call rzero(ruvm,size(ruvm))
        call rzero(ruxm,size(ruxm))
        call rzero(rux2,size(rux2))
        call gtpp_gs_setup(igs_x,nelx,nely,  nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1,nelz,3) ! z-avx
        call interp_setup(intp_h,0.0,0,nelt)
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,1.0,size(xint))
        endif
        do i=1,INTP_NMAX
            j=i-int((i-1)/myint)*myint
            yint(i)=(j-1.)*1./(myint-1)
            yint(i)=tanh(2.5*(yint(i)-1.))/tanh(2.5)+1.
            yint(i)=yint(i)*YLEN
            if (i.le.myint) y_inter(i)=yint(i)
            j=int((i-1)/myint)+1
            zint(i)=(j-1.)*(ZLEN)/(mz-1)
        enddo
        deltaz=zint(myint+1)-zint(1)
        iffpts = .true. ! dummy call to find points
         call interp_nfld(wintr,wo1,1,xint,yint,zint,nint,
     $                   iwk,rwk,INTP_NMAX,iffpts,intp_h)
        iffpts = .false.
        atime = 0.
        timel = time
        icalled = 1
      endif !(icalled.eq.0)
      dtime = time - timel
      atime = atime + dtime
c     ############################################################
c     averaging over time
      if (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 ) then
        beta      = dtime / atime
        alpha     = 1. - beta
c     compute gradients
        call gradm1(vxx,vxy,vxz,vx)
        call gradm1(vyx,vyy,vyz,vy)
        call gradm1(vzx,vzy,vzz,vz)
        call gradm1(tx,ty,tz,t(1,1,1,1,1))

        ifverbose = .false.
c       Compute time-average of u,v,w and t       
        call avg1(rumm(1,1,1,1,1),vx,alpha,beta,n,'uavg',ifverbose)
        call avg1(rumm(1,1,1,1,2),vy,alpha,beta,n,'vavg',ifverbose) 
        call avg1(rumm(1,1,1,1,3),vz,alpha,beta,n,'wavg',ifverbose) 
        call avg1(rumm(1,1,1,1,4),t, alpha,beta,n,'tavg',ifverbose)
c       Compute time-average of u^2,v^2,w^2 and t^2     
        call avg2(ru2m(1,1,1,1,1),vx,alpha,beta,n,'u2mm',ifverbose)
        call avg2(ru2m(1,1,1,1,2),vy,alpha,beta,n,'v2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,3),vz,alpha,beta,n,'w2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,4),t ,alpha,beta,n,'t2mm',ifverbose)

c       Compute time-average of cross products
        call avg3(ruvm(1,1,1,1,1),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg3(ruvm(1,1,1,1,2),vx,vz,alpha,beta,n,'uwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,3),vx, t,alpha,beta,n,'utmm',ifverbose)
        call avg3(ruvm(1,1,1,1,4),vy,vz,alpha,beta,n,'vwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,5),vy, t,alpha,beta,n,'vtmm',ifverbose)
        call avg3(ruvm(1,1,1,1,6),vz, t,alpha,beta,n,'wtmm',ifverbose)
c       Compute time-average of gradients     
        call avg1(ruxm(1,1,1,1,1),vxx,alpha,beta,n,'uxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,2),vxy,alpha,beta,n,'uymm',ifverbose)
        call avg1(ruxm(1,1,1,1,3),vxz,alpha,beta,n,'uzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,4),vyx,alpha,beta,n,'vxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,5),vyy,alpha,beta,n,'vymm',ifverbose)
        call avg1(ruxm(1,1,1,1,6),vyz,alpha,beta,n,'vzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,7),vzx,alpha,beta,n,'wxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,8),vzy,alpha,beta,n,'wymm',ifverbose)
        call avg1(ruxm(1,1,1,1,9),vzz,alpha,beta,n,'wzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,10),tx ,alpha,beta,n,'txmm',ifverbose)
        call avg1(ruxm(1,1,1,1,11),ty ,alpha,beta,n,'tymm',ifverbose)
        call avg1(ruxm(1,1,1,1,12),tz ,alpha,beta,n,'tzmm',ifverbose)
c       Compute time-average of squared gradients
        call avg2(rux2(1,1,1,1,1),vxx,alpha,beta,n,'ux2m',ifverbose)
        call avg2(rux2(1,1,1,1,2),vxy,alpha,beta,n,'uy2m',ifverbose)
        call avg2(rux2(1,1,1,1,3),vxz,alpha,beta,n,'uz2m',ifverbose)

        call avg2(rux2(1,1,1,1,4),vyx,alpha,beta,n,'vx2m',ifverbose)
        call avg2(rux2(1,1,1,1,5),vyy,alpha,beta,n,'vy2m',ifverbose)
        call avg2(rux2(1,1,1,1,6),vyz,alpha,beta,n,'vz2m',ifverbose)

        call avg2(rux2(1,1,1,1,7),vzx,alpha,beta,n,'wx2m',ifverbose)
        call avg2(rux2(1,1,1,1,8),vzy,alpha,beta,n,'wy2m',ifverbose)
        call avg2(rux2(1,1,1,1,9),vzz,alpha,beta,n,'wz2m',ifverbose)

        call avg2(rux2(1,1,1,1,10),tx ,alpha,beta,n,'tx2m',ifverbose)
        call avg2(rux2(1,1,1,1,11),ty ,alpha,beta,n,'ty2m',ifverbose)
        call avg2(rux2(1,1,1,1,12),tz ,alpha,beta,n,'tz2m',ifverbose)
      endif ! (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 )
      timel = time 

c     ############################################################
      if (istep.ne.0 .and. mod(istep,int(iostep_2d_avg_time)).eq.0) then
c     spanwise averaging
        do i =1,12
          call planar_avg(suxm(1,1,1,1,i),ruxm(1,1,1,1,i),igs_x) !x averaging
          call x_slice(suxm_2d(1,1,1,1,i),suxm(1,1,1,1,i),w1,w2)
          call planar_avg(sux2(1,1,1,1,i),rux2(1,1,1,1,i),igs_x) !x averaging
          call x_slice(sux2_2d(1,1,1,1,i),sux2(1,1,1,1,i),w1,w2)
        enddo
        do i =1,6
          call planar_avg(suvm(1,1,1,1,i),ruvm(1,1,1,1,i),igs_x) !x averaging
          call x_slice(suvm_2d(1,1,1,1,i),suvm(1,1,1,1,i),w1,w2)
        enddo
        do i =1,4
          call planar_avg(summ(1,1,1,1,i),rumm(1,1,1,1,i),igs_x) !x averaging
          call x_slice(summ_2d(1,1,1,1,i),summ(1,1,1,1,i),w1,w2)
          call planar_avg(su2m(1,1,1,1,i),ru2m(1,1,1,1,i),igs_x) !x averaging
          call x_slice(su2m_2d(1,1,1,1,i),su2m(1,1,1,1,i),w1,w2)
        enddo
         if (restart_means.eq.0) call output_means(atime,timel,dtime)
      endif !(istep.gt.0 .and. mod(istep,int(iostep_2d_avg_time)).eq.0)
c     ############################################################
c     load restart statistics and average them with the new ones 
      if(restart_means.ne.0 .and. 
     &  mod(istep,int(iostep_2d_avg_time)).eq.0 .and. istep.ne.0) then
        call input_means(timem,atimem,timelm,dtimem)
        t_tot=atime+atimem
        alpha=atime/t_tot
        beta=1-alpha
        ifverbose= .false.
        do i=1,4
          call avg1(summ_2d(1,1,1,1,i),summ_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'uavg',ifverbose)
        enddo
        do i=1,4
          call avg1(su2m_2d(1,1,1,1,i),su2m_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'u2mm',ifverbose)
        enddo
        do i=1,6
           call avg1(suvm_2d(1,1,1,1,i),suvm_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'uvmm',ifverbose)
        enddo
        do i=1,12
           call avg1(suxm_2d(1,1,1,1,i),suxm_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'uxmm',ifverbose)
        enddo
        do i=1,12
           call avg1(sux2_2d(1,1,1,1,i),sux2_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'ux2m',ifverbose)
        enddo
        call output_means(t_tot,timel,dtime)
      endif !(restart_means.eq.1 .and. istep.eq.iostep_2d_avg_time)
c     ############################################################
c     write 2d fld spanwise-averaged files 
      if(mod(istep,int(iostep_2d_notime)).eq.0) then
          if(istep.eq.0)then
              call x_slice(y2d,ym1,w1,w2)
              call x_slice(z2d,zm1,w1,w2)
              icnt_time=1
          endif
          call planar_avg(wo1,vz,igs_x) 
          call x_slice(w2d,wo1,w1,w2)

          call planar_avg(wo1,vy,igs_x) 
          call x_slice(v2d,wo1,w1,w2)

          call planar_avg(wo1,t(1,1,1,1,1),igs_x) 
          call x_slice(tt2d,wo1,w1,w2)
          call outfld2d_yz(z2d,y2d,w2d,v2d,tt2d,ny1,nz1,nely,nelz,'sag',
     &       icnt_time)
          icnt_time=icnt_time+1
      endif


c     ############################################################
c     COMPUTE HYDROSTATIC PRESSURE (AVERAGE OF TEMP(y))
c     FOR REFERENCE ON THIS TERM SEE CANTERO 2009 JGR
      call rzero(tempbar,m) !wo1,2(lx1,ly1,lz1,lelv)
      call cfill(wintr,151413121110987654321.,size(wintr))
      call rzero(tline,myint)
      call planar_avg(wo1,t(1,1,1,1,1),igs_x)  !wo1,2(lx1,ly1,lz1,lelv)

      call interp_nfld(wintr,wo1,1,xint,yint,zint,INTP_NMAX,
     $                       iwk,rwk,INTP_NMAX,iffpts,intp_h)
      if(nid.eq.0) then
        do i=1,myint
          zdum=0.0
          do j=1,mz
              k=i+(j-1)*myint
              if (wintr(k).ne.151413121110987654321.) then
                tline(i)=tline(i)+wintr(k)*deltaz
                zdum=zdum+deltaz
              endif
            enddo
          tline(i)=tline(i)/zdum
        enddo
        call spline(y_inter,tline,myint,wintr2,wintr3)
        do i=1,m
          call splint(y_inter,tline,wintr2,myint,ymm(i,1,1,1),
     $         tempbar(i,1,1,1))
        enddo
      endif
      call rzero(w1,m)
      call gop(tempbar,w1,'+  ',m)

c     ############################################################

      return
      end

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      parameter(nel_slab = nelxin*nelyin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)

      real ewfac
      integer if_pml
      save if_pml

      if (istep.eq.0)then
       if (UTARGET.lt.0.)then
        if_pml=0
       else
        if_pml=1
       endif
      endif

      ux   = 0.
      uy   = 0.
      uz   = 0.
      temp = 0.
c     ############################################################
c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE

      if (if_pml.eq.1) then
        if (ifield .eq. 1) then               ! velocity
          if(ieg.le.nel_slab.and.iside.eq.5) then
            ux  = vxin_pl(ix,iy,ieg)
            uy  = vyin_pl(ix,iy,ieg)
            uz  = vzin_pl(ix,iy,ieg)
          endif
        elseif (ifield .eq. 2) then     !temperature
          temp = 0.0
          if (ieg.le.nel_slab.and.iside.eq.5) then  
            temp  = tin_pl(ix,iy,ieg)
          endif
        endif
      else
        ewfac = -1.0*UTARGET          
        zstart = 0                    !<----------------------CHANGE
        zstart1 = zstart + 1.         !<----------------------CHANGE
        zend = ZLEN
        zend1 = zend - 1.             !<----------------------CHANGE

        if (ifield .eq. 1) then               ! velocity
          if (iside.eq.3) then
              ux = 0.0
c           This coflow is only for the top wall of the domain
              if (z.ge.zstart.and.z.le.zstart1) then
                uy= ((z-zstart-1.)**8 - 1.)*ewfac
              elseif (z.ge.zstart1.and.z.le.zend1) then
                uy= (-1)*ewfac
              elseif (z.ge.zend1.and.z.le.zend) then
                uy= ((z-zend+1.)**8 - 1.)*ewfac
              endif
              uz = 0.0

          elseif(ieg.le.nel_slab.and.iside.eq.5) then
            ux  = vxin_pl(ix,iy,ieg)
            uy  = vyin_pl(ix,iy,ieg)
            uz  = vzin_pl(ix,iy,ieg)
          endif

        elseif (ifield .eq. 2) then     !temperature
          temp = 0.0
          if (ieg.le.nel_slab.and.iside.eq.5) then
            temp  = tin_pl(ix,iy,ieg)
          endif
        endif
      endif
c     ############################################################
c     #########################################################

      return
      end

      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0



      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      
      integer n,nelytot,mmnely
      real hfh,hfint,amp,delyi,rrleny,rrlenyint,y,z
      real theta1, theta2, A1, A2, zh

      theta1=atan(1/RITAU)
      theta2=atan(1/Ri_tau2)
      zh=(ZLEN)/2.0
      A1=zh/RITAU   !zh*tan(theta)
      A2=zh/RITAU2
C       A1=0
C       A2=0
      n=8*nelt
c
      nelytot = NUMBER_ELEMENTS_Y

      delyi =hf/nelyin
      rrleny = nelytot*delyi 
      rrlenyint = nelyint*delyi
      hfh=hf/2.0
      hfint = rrlenyint
      amp = (ASINH((4.0/6.0)*SINH(-3.25)))/(-0.7*3.25)

c     vertical grid spacing      
      do i=1,n
        yc(i,1)  = rrleny * yc(i,1) 
        y=yc(i,1)

        if (y.le.hfh) then
          yc(i,1) = (-1)*(1-SINH(3.25*y)/SINH(3.25))+1
        elseif (y.le.hf) then
          yc(i,1) = (1)*(1 - SINH(3.25*(2-y))/SINH(3.25))+1
        elseif (y.le.hfint) then
          y = y / rrlenyint
          yc(i,1)= (6*SINH(3.25*amp*(0.3-y))/SINH(-3.25))+2
        elseif (y.gt.hfint) then
          y = y/rrleny
          yc(i,1)=y*nelytot-(nelytot-YLEN)
        endif
        xc(i,1) =  XLEN * xc(i,1)
        zc(i,1) = ZLEN * zc(i,1)
      enddo


c     sloping
      do i=1,n
        y=yc(i,1)
        z=zc(i,1)
        if(z.lt.zh) then
          if(y.le.hfint) then
            yc(i,1)=y+A1*((-1.0/zh)*z+1)+A2
          else
            yc(i,1)=y+((-A1/(YLEN-hfint))*(y-hfint)+A1)*
     &                ((-1.0/zh)*z+1)+
     &                ((-A2/(YLEN-hfint))*(y-hfint)+A2)
          endif !(y.le.hfint)
        else
          if(y.le.hfint) then
            yc(i,1)=y+A2*((-1.0/zh)*(z-zh)+1)
          else
            yc(i,1)=y+((-A2/(YLEN-hfint))*
     &         (y-hfint)+A2)*((-1.0/zh)*
     &                (z-zh)+1)
          endif !(y.le.hfint)
        endif !(z.lt.zh)
      enddo

      return
      end
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      if (UTARGET.lt.0.)then  !change top BC from O to v
          ifc=3 !top face, if it was generated by genbox
          do iel=1,nelt
          if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'v  '
          enddo
      endif

      call opcopy(xmo,ymo,zmo,xm1,ym1,zm1)  ! Preserve my geometry
c
      return
      end
      
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end

c-----------------------------------------------------------------------
      subroutine planar_inflow(ua,u,mnelin,w1)
c
c     Compute r-s planar average of quantity u()
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      integer e,eg,mnelin,nxyin
      real u(nx1*ny1,mnelin),aindum(nx1*ny1,mnelin)
      real ain(nx1*ny1,mnelin),ua,uadum,w1,w1dum
c
c     As the numbering of elements in a single box
c     go in the order of r-s-t (first fill r, then 
c     s and then t) the ordering of the 2d elements 
c     in u (2d inlet) is the same as the first 
c     t-plane of elements in the 3d box. Hence,
c     face 5 of the first mnelin elements of the 
c     3dbox have the same area as the 2d inlet.

      nxyin = nx1*ny1*mnelin
      call rzero(ain,nxyin)
      call rzero(aindum,nxyin)
      do e=1,nelt
c        l local gl global el element
         eg = lglel(e)
         if (eg.le.mnelin) then
           do i=1,nx1*ny1
              aindum(i,eg) = area(i,1,5,e)
           enddo
         endif
      enddo
      call gop(aindum,ain,'+  ',nxyin)

      ua=0.0
      uadum=0.0
      w1=0.0
      w1dum=0.0

      if (nid.eq.0) then
       do e=1,mnelin
          do i=1,nx1*ny1
            w1dum = w1dum + ain(i,e)
            uadum = uadum + ain(i,e)*u(i,e)
          enddo
       enddo
       uadum = uadum / w1dum ! Normalize
      endif
      call gop(ua,uadum,'+  ',1)      
      call gop(w1,w1dum,'+  ',1)      


      return
      end

c----------------------------------------------------------------
      subroutine interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin1,z_inflow,rlenz
     $          ,dtimestep,restart_inflow1)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer step_inflow,nelzin1,nel_slab,nelin
      integer restart_inflow1
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)



      real zz(nz1,nelz),w1(nz1,nelz),w2(nz1,nelz)
      real zzin(nz1,nelzin1)
      integer nzin,flagin,e,m

      real vzinavg,uadum,w1in,z_sup,z_inf
      integer k_sup,k_inf,ez_in,e_pl

      real vxin_pl_dum(lx1,ly1,nel_slab)
     $    ,vyin_pl_dum(lx1,ly1,nel_slab)
     $    ,vzin_pl_dum(lx1,ly1,nel_slab)
     $    ,tin_pl_dum(lx1,ly1,nel_slab)

      real z_inflow_dum

c     ---------------------------------------------------------
      m = nx1*ny1*nel_slab
      call planar_average_z(zz,zm1,w1,w2)
      nzin=nelzin1*nz1
      call copy(zzin,zz,nzin)
      if (istep.eq.0.and.restart_inflow1.eq.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
         z_inflow = rlenz
         do e=1,nel_slab
          e_pl = nel_slab*(nelzin1-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e) = vxin(i,j,nz1,e_pl)
              vyin_pl(i,j,e) = vyin(i,j,nz1,e_pl)
              vzin_pl(i,j,e) = vzin(i,j,nz1,e_pl)
              tin_pl(i,j,e) = tin(i,j,nz1,e_pl)
            enddo
          enddo
         enddo

      elseif (istep.eq.0.and.restart_inflow1.eq.1) then
c       This part has to be done by only nid.eq.0
c       (could generate reading issues otherwise)
        z_inflow = 0.0
        z_inflow_dum = 0.0
        call rzero(vxin_pl,m)
        call rzero(vyin_pl,m)
        call rzero(vzin_pl,m)
        call rzero(tin_pl,m)
        call rzero(vxin_pl_dum,m)
        call rzero(vyin_pl_dum,m)
        call rzero(vzin_pl_dum,m)
        call rzero(tin_pl_dum,m)
        if (nid.eq.0) then
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART ####'
          open(unit=58,file='inflow2d.ini',access='stream',
     &       form='unformatted')
          read(58) z_inflow_dum
          read(58) vxin_pl_dum,vyin_pl_dum,vzin_pl_dum,tin_pl_dum
          close(58)
          write(*,*)'FILE: inflow2d.ini'
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART DONE ###'
        endif
        call gop(z_inflow_dum,z_inflow,'+  ',1)
        call gop(vxin_pl_dum,vxin_pl,'+  ',m)
        call gop(vyin_pl_dum,vyin_pl,'+  ',m)
        call gop(vzin_pl_dum,vzin_pl,'+  ',m)
        call gop(tin_pl_dum,tin_pl,'+  ',m)

      elseif (istep.gt.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
        call planar_inflow(vzinavg,vzin_pl,nel_slab,w1in)
       
        dz_inflow = dtimestep * vzinavg
        if (z_inflow.lt.dz_inflow) then
          z_inflow = rlenz - (dz_inflow - z_inflow)
        else
          z_inflow = z_inflow - dz_inflow
        endif


        flagin=0
        do e=nelzin1,1,-1
          do k=nz1,1,-1
            if (z_inflow.gt.zzin(k,e).and.flagin.eq.0) then
              z_sup = zzin(k+1,e)
              z_inf = zzin(k,e)
              k_sup = k+1
              k_inf = k
              ez_in = e
              flagin=1
            endif
          enddo
        enddo

        do e=1,nel_slab
          e_pl = nel_slab*(ez_in-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e)=((vxin(i,j,k_sup,e_pl)-
     $                       vxin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vxin(i,j,k_inf,e_pl)

              vyin_pl(i,j,e)=((vyin(i,j,k_sup,e_pl)-
     $                       vyin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vyin(i,j,k_inf,e_pl)

              vzin_pl(i,j,e)=((vzin(i,j,k_sup,e_pl)-
     $                       vzin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vzin(i,j,k_inf,e_pl)

              tin_pl(i,j,e) =((tin(i,j,k_sup,e_pl)-
     $                       tin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       tin(i,j,k_inf,e_pl)
            enddo
          enddo
        enddo

      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine x_slice (ua,u,w1,w2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nz1,nely,nelz),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nz1,nely,nelz),w2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w2,'+  ',myz)

      return
      end

c---------------------------------------------------------------------      
      subroutine y_line (ua,u,w1,w2)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
      real dy2
c
      my = nely*ny1
      call rzero(ua,my)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1) then
            do j=1,ny1
               ua(j,ey) = u(i,j,k,e)
            enddo
         endif
      enddo
      call gop(ua,w2,'+  ',my)

      return
      end
c---------------------------------------------------------------------      
C       subroutine z_line (ua,u,w1,w2)
C c
C c     Extract a z line of quantity u() - assumes global tens.prod.
C c
C       include 'SIZE'
C       include 'GEOM'
C       include 'PARALLEL'
C       include 'WZ'
C       include 'ZPER'
C c
C       real ua(nz1,nelz),u(nx1,ny1,nz1,nelv)
C       real w1(nz1,nelz),w2(nz1,nelz)
C       integer e,eg,ex,ey,ez
C       real dy2
C c
C       mz = nelz*nz1
C       call rzero(ua,mz)
C       call rzero(w1,mz)
C       call rzero(w2,mz)
C c
C       do e=1,nelt
C c
C          eg = lglel(e)
C          call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
C          i = 1
C          j = 1
C          if (ex.eq.1 .and. ey.eq.1) then
C             do k=1,nz1
C                ua(k,ez) = u(i,j,k,e)
C             enddo
C          endif
C       enddo

C       call gop(ua,w2,'+  ',mz)
 
C       return
C       end

c     ############################################################
      subroutine output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl
     $                           ,nel_slab,z_inflow)
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z_inflow
      integer nel_slab

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)

      character*80 istepc_inflow,icfile_inflow
c    ----------------------------------------------------------

      if (nid.eq.0) then
        write(istepc_inflow,'(i32)') istep
        istepc_inflow=adjustl(istepc_inflow)
        icfile_inflow=trim('inflow2d'//'.'//trim(istepc_inflow))
        open(unit=58,file=icfile_inflow,access='stream',
     &     form='unformatted')
        write(58) z_inflow
        write(58) vxin_pl,vyin_pl,vzin_pl,tin_pl
        close(58)
      endif

      return
      end
c----------------------------------------------------------------------

      subroutine read_inflow(vxin,vyin,vzin,tin,nelin,nin)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelin,nin

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)


      real dum(nx1,ny1,nz1,nelin)
      character*80 icfile
c     -----------------------------------------------------

      call rzero(vxin,nin)
      call rzero(vyin,nin)
      call rzero(vzin,nin)
      call rzero(tin,nin)

c      Zero all dummy arrays
       call rzero(dum,nin)
       call rzero(vxin,nin)
       call rzero(vyin,nin)
       call rzero(vzin,nin)
       call rzero(tin,nin)
c      Read IC file
      if (nid.eq.0) then
         icfile=trim('vx_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vxin
         close(58)
         icfile=trim('vy_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vyin
         close(58)
         icfile=trim('vz_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vzin
         close(58)
         icfile=trim('temp_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) tin
         close(58)
      endif
c     Add through all processors  
      call gop(vxin,dum,'+  ',nin)
      call gop(vyin,dum,'+  ',nin)
      call gop(vzin,dum,'+  ',nin)
      call gop(tin,dum,'+  ',nin)

      return
      end

c-----------------------------------------------------------------------
      subroutine planar_average_z(ua,u,w1,w2)
c
c     Compute r-s planar average of quantity u() USED IN INTERPOLATE INFLOW
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nz1,nelz),u(nx1*ny1,nz1,nelv),w1(nz1,nelz),w2(nz1,nelz)
      integer e,eg,ez
c
      melxy = nelx*nely
c
      nz = nz1*nelz
      call rzero(ua,nz)
      call rzero(w1,nz)
c
      do e=1,nelt
c
         eg = lglel(e)
         ez = 1 + (eg-1)/melxy
c
         do k=1,nz1
         do i=1,nx1*ny1
            zz = (1.-zgm1(k,3))/2.  ! = 1 for k=1, = 0 for k=nz1
            aa = zz*area(i,1,5,e) + (1-zz)*area(i,1,6,e)  ! wgtd jacobian
            w1(k,ez) = w1(k,ez) + aa
            ua(k,ez) = ua(k,ez) + aa*u(i,k,e)
         enddo
         enddo
      enddo
c
      call gop(ua,w2,'+  ',nz)
      call gop(w1,w2,'+  ',nz)
c
      do i=1,nz
         ua(i,1) = ua(i,1) / w1(i,1)   ! Normalize
      enddo
c
      return
      end

       subroutine output_means(atime,timel,dtime)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real atime,timel,dtime
       character*80 icfile,istepc
       common /gaaa/ w4(ly1,lz1,lely,lelz)

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)


       m=ny1*nz1*lely*lelz
       if(nid.eq.0) then
          write(*,*)'*********Writing statistics.......*********'
          write(istepc,'(i32)') istep
          istepc=adjustl(istepc)
          icfile=trim('means.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) time,atime,timel,dtime
          write(58) int(nx1),int(lelx),int(lely),int(lelz)
          do i=1,4
            call copy(w4,summ_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su2m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          do i=1,6
            call copy(w4,suvm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,suxm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,sux2_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          close(58)
       endif
       return
       end

      subroutine input_means(time_old,atime,timel,dtime)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real time_old
      real atime,timel,dtime
      real w4(ly1,lz1,lely,lelz)
      integer dumm

      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)

      m=ny1*nz1*lely*lelz

      call rzero(summ_2d_o,size(summ_2d_o))
      call rzero(su2m_2d_o,size(su2m_2d_o))
      call rzero(suvm_2d_o,size(suvm_2d_o))
      call rzero(suxm_2d_o,size(suxm_2d_o))
      call rzero(sux2_2d_o,size(sux2_2d_o))

      if (nid.eq.0) then
         write(*,*)'*********Reading means file: means.ini....*********'
         open(unit=58,file='means.ini',access='stream',
     &     form='unformatted')
         read(58) time_old, atime,timel,dtime
         read(58) dumm,dumm,dumm,dumm
         do i=1,4
          read(58) w4
          call copy(summ_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
          read(58) w4
          call copy(su2m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
          read(58) w4
          call copy(suvm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(suxm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(sux2_2d_o(1,1,1,1,i),w4,m)
         enddo
         close(58)
       endif
      do i=1,4
          call gop(summ_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(su2m_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,6
          call gop(suvm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,12
          call gop(suxm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,12
          call gop(sux2_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      
      return
      end

      subroutine print_yz_mesh

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real ymm(ly1,lz1,lely,lelz),zmm(ly1,lz1,lely,lelz)

c     xmm --> yz slice; ymm --> xz slice; zmm --> xy slice  

      real w1(ly1,lz1,lely,lelz),w2(ly1,lz1,lely,lelz)


      call x_slice(ymm,ym1,w1,w2)
      call x_slice(zmm,zm1,w1,w2)

      if(nid.eq.0) then
          write(*,*)'*********Writing y-z plane mesh.......*********'
          write(istepc,'(i32)') istep
          open(unit=58,file='yzmesh.dat',
     &       access='stream',form='unformatted')
          write(58)ly1,lz1,lely,lelz
          write(58)ymm,zmm
          close(58)
      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine outfld2d_yz(z,y,w,v,tt,ny,nz,nly,nlz,name,ifld)

      include 'SIZE'
      include 'TOTAL'

      real z(ny,nz,nly,nlz)
      real y(ny,nz,nly,nlz)
      real v(ny,nz,nly,nlz)
      real w(ny,nz,nly,nlz)
      real tt(ny,nz,nly,nlz)
      character*3 name

      character*2  excode(15)
      character*12 fm
      character*20 outfile

c     if (istep.le.10) write(6,*) nid,' in out2d:',iz

      call blank(excode,30)
c
      excode(1) = 'X '
      excode(2) = 'Y '
c     excode(3) = 'U '
c     excode(4) = 'V '
c     excode(5) = 'P '
c     excode(6) = 'T '
c
      excode(4) = 'U '
      excode(5) = '  '
      excode(6) = 'T '
      nthings   =  6

      ierr = 0 
      if (nid.eq.0) then
         write(*,*)'******Writing spanwise-averaged fld file....*******'
         call blank(outfile,20)
         if (ifld.lt.100) then
            write(outfile,2) name,ifld
    2       format(a3,'2d.fld',i2.2)
         elseif (ifld.lt.1000) then
            write(outfile,3) name,ifld
    3       format(a3,'2d.fld',i3)
         elseif (ifld.lt.10000) then
            write(outfile,4) name,ifld
    4       format(a3,'2d.fld',i4)
         elseif (ifld.lt.100000) then
            write(outfile,5) name,ifld
    5       format(a3,'2d.fld',i5)
         elseif (ifld.lt.1000000) then
            write(outfile,6) name,ifld
    6       format(a3,'2d.fld',i6)
         endif
         open(unit=24,file=outfile,status='unknown')
         call dump_header2d(excode,ny,nz,nly,nlz,ierr)

         n = ny*nz*nly*nlz
c        write(6,*) fm
c        call exitt
C          write(24,fm) (z(i),y(i),u(i),v(i),w(i),t(i),i=1,n)

          do l=1,nlz
             do k=1,nly
                 do j=1,nz
                   do i=1,ny
                     write(24,'(1p5e14.6)') z(i,j,k,l),y(i,j,k,l),
     &                   w(i,j,k,l),v(i,j,k,l),tt(i,j,k,l)
                   enddo
                 enddo
              enddo
          enddo
c  10    format('''(1p',i1,'e15.7)''')
c  10    format(1p7e15.7)
c
         close(24)
      endif
      call err_chk(ierr,'Error using byte_write,outfld2d. Abort.$')

      return
      end

      subroutine spline(x,y,n,y2,u)
C       parameter (nmax=10000000)
C       dimension x(n),y(n),y2(n),u(n)
      real x(n),y(n),y2(n),u(n)
C       if (n.gt.nmax) then
C          write(6,11) n,nmax
C    11    FORMAT(2X,'ERROR:  Attempt to fit a spline with',I5
C      $            ,'greater than',I4,' points.'
C      $       ,/,2X,'Recompile routine SPLINE.')
C          call exitti('routine spline fail$',n)
C       endif
      y2(1)=0.0
      u(1) =0.0
      do i=2,n-1
         ir=i+1
         il=i-1
         sig=(x(i)-x(il))/(x(ir)-x(il))
         p=sig*y2(il)+2.
         y2(i)=(sig-1.)/p
         u(i)= ( 6.*
     $     ( (y(ir)-y(i))/(x(ir)-x(i))-(y(i)-y(il))/ (x(i)-x(il) ) )
     $            / (x(ir)-x(il))
     $    - sig*u(il) )/p
      enddo
      qn=0.0
      un=0.0
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.)
      do k=n-1,1,-1
         y2(k)=y2(k)*y2(k+1)+u(k)
      enddo
      return
      end

      subroutine splint(xa,ya,y2a,n,x,y)
c     p. 88-89, numerical recipes
      real xa(n),ya(n),y2a(n)
      klo=1
      khi=n
    1   if ((khi-klo).gt.1) then
           k=(khi+klo)/2
           if (xa(k).gt.x) then
              khi=k
           else
              klo=k
           endif
           goto 1
        endif
      h=xa(khi)-xa(klo)
      if (h.eq.0) then
C          write(6,*) xa(khi), 'splint failure',khi
          y=0.0
         return
      endif
      a=(xa(khi)-x)/h
      b=(x-xa(klo))/h
      y=a*ya(klo)+b*ya(khi)+
     $  ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.
      return
      end

      subroutine set_IC(vxin,vyin,vzin,tin,nelin,nelx_in,nely_in,nelz_in
     $                 ,nel_slab)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelx_in,nel_slab,nelin,nely_in,ex,ey,ez,eg,e,nxyz,egchnl
      integer nchnlon,nelz_in,ez1
      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      character*80 icfile,istepc
c     -----------------------------------------------------
      nxyz = nx1*ny1*nz1

      do e=1,nelv
        eg = lglel(e)
        call  get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
        if (ey.le.nely_in) then
          if (mod(ez,nelz_in).eq.0) then
            nchnlon = int(ez/nelz_in)
          else
            nchnlon = int(ez/nelz_in)+1
          endif
          ez1 = ez - (nchnlon-1)*nelz_in
          egchnl = nel_slab*(ez1-1)+nelx_in*(ey-1)+ex !Global element number
          call copy(vx(1,1,1,e),vxin(1,1,1,egchnl),nxyz)
          call copy(vy(1,1,1,e),vyin(1,1,1,egchnl),nxyz)
          call copy(vz(1,1,1,e),vzin(1,1,1,egchnl),nxyz)
        endif
      enddo

      do e=1,nelt
        eg = lglel(e)
        call  get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
        if (ey.le.nely_in) then
          if (mod(ez,nelz_in).eq.0) then
            nchnlon = int(ez/nelz_in)
          else
            nchnlon = int(ez/nelz_in)+1
          endif
          ez1 = ez - (nchnlon-1)*nelz_in
          egchnl = nel_slab*(ez1-1)+nelx_in*(ey-1)+ex !Global element number
          call copy(t(1,1,1,e,1),tin(1,1,1,egchnl),nxyz)
        endif
      enddo
      return
      end 

c- constants -----------------------------------------------------------

#define iostep_2d_avg_time  uparam(1) /* output frequency for statistics */
#define VISCFAC uparam(2)             /* viscosity multiplier at ouflow */
#define RITAU uparam(3)               /* Ri_tau */
#define UTARGET uparam(4)             /* u_target for top PML, positive */ 
#define restart_inflow uparam(5)      /* whether to read inflow2d.ini (2d) for restasting */
#define iostep_inflow uparam(6)       /* frequency of output for inflow2d file */
#define delta_fltr uparam(7)          /* integration filter limit */
#define restart_means uparam(8)       /* Restart of means flag (reads means.ini binary files) */

#define RE_TAU (1/param(2))
c - mesh and buffer zones dimensions
#define PI (4.*atan(1.))
#define ZLEN (32.*PI)
#define XLEN (8.*PI/3.)
#define YLEN 20.
#define ZBUFF (31.*PI)
#define YBUFF 12.
#define NUMBER_ELEMENTS_X 15
#define NUMBER_ELEMENTS_Y 44
#define NUMBER_ELEMENTS_Z 112

c - Iflow dimensions
#define nelxin 15 /*number of elements of inflow array */
#define nelyin 9
#define nelzin 28
c#define hf 2.0 /*height of inflow domain*/


      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     TURBULENT OUTFLOW
c     Sets low Re number in range [zout;lenz]
      real zout
       
      zout = ZLEN-PI                               !<----------CHANGE!
      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)
         if (z.ge.zout)then
               udiff =((param(2)*VISCFAC-param(2))/PI)
     $            *(z-zout) + param(2)
         endif
      else if(ifield.eq.2)then                    ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (z.ge.zout) then
          udiff =((param(8)*VISCFAC - param(8))/PI)
     $           *(z-zout) + param(8)
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz


      real*8 egrav(3)

c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lely)
     &             ,w1t(ly1,lely)
     &             ,w2t(ly1,lely)
c
      integer ex,ey,ez

c     BUFFER ZONE VARIABLES
      real*8 sigma2(3),sigmam1(3),sigmam2(3),beta,ybuff  !changed sigma to sigma2
     $        ,zbuff,umean1(3),umean2(3),yy,zz,m,vzout

c     MESH VARIABLES
      egrav(1) = 0.0                !x: Spanwise direction
      egrav(2) = (-1)*RITAU         !y: Wall-normal direction
      egrav(3) = 1.0                !z: Streamwise direction

c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
      call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

      ffx = temp*egrav(1)
      ffy = (temp - tempbar(iy,ey))*egrav(2)
      ffz = temp*egrav(3)
c     ############################################################
c     ############################################################

c     ############################################################
c     ############################################################
c     Buffer zones
      sigmam1(1) = 0.0                          !<-----------------CHANGE!
      sigmam1(2) = 1.0                          !<-----------------CHANGE!
      sigmam1(3) = 0.0                          !<-----------------CHANGE!

      sigmam2(1) = 0.0                          !<-----------------CHANGE!
      sigmam2(2) = 0.0                          !<-----------------CHANGE!
      sigmam2(3) = 0.0                          !<-----------------CHANGE!

      beta = 2.0                                !<-----------------CHANGE!

      umean1(1) = 0.0                           !<-----------------CHANGE! 
      umean1(2) =-UTARGET                       
      umean1(3) = 0.0                           !<-----------------CHANGE! 
      
      umean2(1) = 0.0                           !<-----------------CHANGE! 
      umean2(2) = 0.0                           !<-----------------CHANGE! 
      umean2(3) = 0.0                           !<-----------------CHANGE! 

      m=(YLEN-YBUFF)/(ZLEN-ZBUFF)
      zz = (y-YBUFF)/m + ZBUFF
      yy = m * (z-ZBUFF) + YBUFF

c     ###############
c     Top buffer zone
      sigma2(1) = 0.0
      sigma2(2) = 0.0
      sigma2(3) = 0.0
      if (y.ge.YBUFF.and.z.le.zz) then
        sigma2(1) = sigmam1(1)*((y - YBUFF)/(YLEN-YBUFF))**(beta)
        sigma2(2) = sigmam1(2)*((y - YBUFF)/(YLEN-YBUFF))**(beta)
        sigma2(3) = sigmam1(3)*((y - YBUFF)/(YLEN-YBUFF))**(beta)

        ffx = ffx - sigma2(1) * (ux - umean1(1))
        ffy = ffy - sigma2(2) * (uy - umean1(2)) 
        ffz = ffz - sigma2(3) * (uz - umean1(3))
      endif

c     ###################
c     Outflow buffer zone
C       if(.FALSE.) then
C           sigma2(1) = 0.0
C           sigma2(2) = 0.0
C           sigma2(3) = 0.0
C           call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
C           vzout = vzout_pl(ix,iy,ex,ey)
C           if (z.ge.ZBUFF.and.y.lt.yy.and.vzout.lt.0.0) then
C             sigma2(1) = sigmam2(1)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)
C             sigma2(2) = sigmam2(2)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)
C             sigma2(3) = sigmam2(3)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)

C             ffx = ffx - sigma2(1) * (ux - umean2(1))
C             ffy = ffy - sigma2(2) * (uy - umean2(2))
C             ffz = ffz - sigma2(3) * (uz - umean2(3))
C           endif
C       endif
c     ####################
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)
 
      qvol   = 0.0
      source = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

c     ############################################################
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
      integer nelin,nel_slab,nin
      real rlenz,z_inflow,dz_inflow
      real dtimestep
      integer set_IC_flag

c     If set_IC_flag.eq.1 copy inflow file at bottom of big domain
      parameter(set_IC_flag=0)                           !<----- CHANGE!

      parameter(nelin=nelxin*nelyin*nelzin)
      parameter(nel_slab=nelxin*nelyin)
      parameter(nin = nelin*lx1*ly1*lz1)

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)
      save z_inflow

c     ############################################################
c     DEPTH-AVERAGED STATISTICS VARIABLES

c     Output frequency of span-time-averaged .fld files
c     and means.* binary files

c     Output frequency of span-averaged .fld files
      integer iostep_2d
      parameter( iostep_2d= 1000 )          !<-----------CHANGE!

c     Integration filter: The moments of velocity and concentration
c     are computed from z=0 to z=z_delta_fltr where z_delta_fltr
c     is the wall-normal location where we find a concentration
c     c<=delta_fltr


      real timem,atimem,timelm,dtimem

c     spanwise-averaged arrays
      real    yavgx(ny1,nz1,lely,lelz)
     $    ,   zavgx(ny1,nz1,lely,lelz)

      parameter(nstat=38)
      real rumm(lx1,ly1,lz1,lelt,4)
      real ru2m(lx1,ly1,lz1,lelt,4)
      real ruvm(lx1,ly1,lz1,lelt,6)
      real ruxm(lx1,ly1,lz1,lelt,12)
      real rux2(lx1,ly1,lz1,lelt,12)
      real summ(lx1,ly1,lz1,lelt,4)
      real su2m(lx1,ly1,lz1,lelt,4)
      real suvm(lx1,ly1,lz1,lelt,6)
      real suxm(lx1,ly1,lz1,lelt,12)
      real sux2(lx1,ly1,lz1,lelt,12)
c      real stat(lx1*ly1*lz1*lelt,nstat)
c      real stat2d(ly1,lz1,lely,lelz,nstat)
c      save ravg, stat, stat2d
      save rumm,rux2,ruvm,ruxm,rux2,summ,sux2,suvm,suxm,sux2
      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      real             w1(ly1,lz1,lely,lelz)
     $              ,  w2(ly1,lz1,lely,lelz)
     &              ,  w3(ly1,lz1,lely,lelz)
     &              ,  w4(ly1,lz1,lely,lelz)

      save igs_x, igs_z

c     depth-averaged arrays
      real zavgxy(nz1,lelz)

c     depth-averaged arrays
C       real uavgxy(nz1,lelz)
C      $    ,vavgxy(nz1,lelz)
C      $    ,wavgxy(nz1,lelz)
C      $    ,tavgxy(nz1,lelz)
C      $    ,w2avgxy(nz1,lelz)
C      $    ,wtavgxy(nz1,lelz)
C      $    ,wkavgxy(nz1,lelz)
C      $    ,prodavgxy(nz1,lelz)
C      $    ,dissavgxy(nz1,lelz)

C c     depth-averaged arrays (filtered)
C       real    uavgxy_fltr(nz1,lelz)
C      $       ,vavgxy_fltr(nz1,lelz)
C      $       ,wavgxy_fltr(nz1,lelz)
C      $       ,tavgxy_fltr(nz1,lelz)
C      $       ,w2avgxy_fltr(nz1,lelz)
C      $       ,wtavgxy_fltr(nz1,lelz)
C      $       ,wkavgxy_fltr(nz1,lelz)
C      $       ,prodavgxy_fltr(nz1,lelz)
C      $       ,dissavgxy_fltr(nz1,lelz)
c

c     dWh/dz (from cons. of mass dUh/dz=we)
      real    dzwavgxy(nz1,lelz),
     $        dzwavgxy_fltr(nz1,lelz)
c
c     Interface position array (intr) and threshold delta
      real intr(nz1,lelz)

c     average in time variables
      integer icalled
      save    icalled
      data    icalled /0/

      real atime,timel
      save atime,timel
      real alpha,beta
      integer n,nt

      integer icnt_time
      save    icnt_time
      data    icnt_time /0/

      integer icnt
      save    icnt
      data    icnt /0/
c
      character*32 istepc,outfile

      character*80 icfile
c
c     Gradient arrays for shear velocity, 
c     tke production and dissipation computation
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vyx(lx1,ly1,lz1,lelv),
     $     vyy(lx1,ly1,lz1,lelv),
     $     vyz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv),
     $     tx(lx1,ly1,lz1,lelv),
     $     ty(lx1,ly1,lz1,lelv),
     $     tz(lx1,ly1,lz1,lelv)

      real t_tot, t_old, t_new
c     ############################################################
c
c     ############################################################
c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lely)
     $             ,w1t(ly1,lely)
     $             ,w2t(ly1,lely)

      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z
      n=nx1*ny1*nz1*nelv  
      nt=nx1*ny1*nz1*nelt
      m=ny1*nz1*nely*nelz
c
cc     ############################################################
cc     BUFFER REGION VARIABLES (by JS, has not been modified)
c      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)
c      real vzout_pldum(lx1,ly1,lelx,lely)
c      integer ex,ey,ez,eg
c      integer iostep_outflow,iostep_outflow_notime
c      real vmax,vmaxdum,zmax,wmin,wmindum,ymin
c
cc     Output frequency of outflow boundaries statistics    
c      parameter(iostep_outflow = 1000)               !<----- CHANGE!
c      parameter(iostep_outflow_notime = 1000)        !<----- CHANGE!
cc     ############################################################

c     ############################################################
c
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
c
c     This code is made for a mesh composed of only one box.
c     Computes the inlet boundary condition for the next time step
c     interpolating the solution for a TC with fixed mean 
c     streamwise velocity and concentration

      dtimestep = abs(PARAM(12))
c     READ INFLOW
      if (istep.eq.0) then
        call read_inflow(vxin,vyin,vzin,tin,nelin,nin)
        if (set_IC_flag.eq.1) then
          call set_IC(vxin,vyin,vzin,tin,nelin,nelxin,nelyin,nelzin
     $               ,nel_slab)
        endif
      endif

      call interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow,ZLEN
     $          ,dtimestep,int(restart_inflow))

      if (mod(istep,int(iostep_inflow)).eq.0) then
c        call output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl,nel_slab
c     $                       ,z_inflow)
      endif
c     ############################################################
c     OUTPUT INITIAL CONDITION
      if (istep.eq.0) then
        ifxyo = .true.
        call prepost(.true.,'   ' )
        ifxyo = .false.
      endif
c     ############################################################
c
      if(icalled.eq.0) then
        call rzero(rumm,size(rumm))
        call rzero(ru2m,size(ru2m))
        call rzero(ruvm,size(ruvm))
        call rzero(ruxm,size(ruxm))
        call rzero(rux2,size(rux2))
        call gtpp_gs_setup(igs_x,nelx,nely,  nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1,nelz,3) ! z-avx
        atime = 0.
        timel = time
        icalled = 1
      endif !(icalled.eq.0)
      dtime = time - timel
      atime = atime + dtime
c     ############################################################

c     compute gradients
      call gradm1(vxx,vxy,vxz,vx)
      call gradm1(vyx,vyy,vyz,vy)
      call gradm1(vzx,vzy,vzz,vz)
      call gradm1(tx,ty,tz,t(1,1,1,1,1))
c     ############################################################
c     averaging over time
      if (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 ) then
        beta      = dtime / atime
        alpha     = 1. - beta

        ifverbose = .false.
c       Compute time-average of u,v,w and t       
        call avg1(rumm(1,1,1,1,1),vx,alpha,beta,n,'uavg',ifverbose)
        call avg1(rumm(1,1,1,1,2),vy,alpha,beta,n,'vavg',ifverbose) 
        call avg1(rumm(1,1,1,1,3),vz,alpha,beta,n,'wavg',ifverbose) 
        call avg1(rumm(1,1,1,1,4),t, alpha,beta,n,'tavg',ifverbose)

c       Compute time-average of u^2,v^2,w^2 and t^2     
        call avg2(ru2m(1,1,1,1,1),vx,alpha,beta,n,'u2mm',ifverbose)
        call avg2(ru2m(1,1,1,1,2),vy,alpha,beta,n,'v2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,3),vz,alpha,beta,n,'w2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,4),t ,alpha,beta,n,'t2mm',ifverbose)

c       Compute time-average of cross products
        call avg3(ruvm(1,1,1,1,1),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg3(ruvm(1,1,1,1,2),vx,vz,alpha,beta,n,'uwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,3),vx, t,alpha,beta,n,'utmm',ifverbose)
        call avg3(ruvm(1,1,1,1,4),vy,vz,alpha,beta,n,'vwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,5),vy, t,alpha,beta,n,'vtmm',ifverbose)
        call avg3(ruvm(1,1,1,1,6),vz, t,alpha,beta,n,'wtmm',ifverbose)

c       Compute time-average of gradients     
        call avg1(ruxm(1,1,1,1,1),vxx,alpha,beta,n,'uxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,2),vxy,alpha,beta,n,'uymm',ifverbose)
        call avg1(ruxm(1,1,1,1,3),vxz,alpha,beta,n,'uzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,4),vyx,alpha,beta,n,'vxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,5),vyy,alpha,beta,n,'vymm',ifverbose)
        call avg1(ruxm(1,1,1,1,6),vyz,alpha,beta,n,'vzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,7),vzx,alpha,beta,n,'wxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,8),vzy,alpha,beta,n,'wymm',ifverbose)
        call avg1(ruxm(1,1,1,1,9),vzz,alpha,beta,n,'wzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,10),tx ,alpha,beta,n,'txmm',ifverbose)
        call avg1(ruxm(1,1,1,1,11),ty ,alpha,beta,n,'tymm',ifverbose)
        call avg1(ruxm(1,1,1,1,12),tz ,alpha,beta,n,'tzmm',ifverbose)

c       Compute time-average of squared gradients
        call avg2(rux2(1,1,1,1,1),vxx,alpha,beta,n,'ux2m',ifverbose)
        call avg2(rux2(1,1,1,1,2),vxy,alpha,beta,n,'uy2m',ifverbose)
        call avg2(rux2(1,1,1,1,3),vxz,alpha,beta,n,'uz2m',ifverbose)

        call avg2(rux2(1,1,1,1,4),vyx,alpha,beta,n,'vx2m',ifverbose)
        call avg2(rux2(1,1,1,1,5),vyy,alpha,beta,n,'vy2m',ifverbose)
        call avg2(rux2(1,1,1,1,6),vyz,alpha,beta,n,'vz2m',ifverbose)

        call avg2(rux2(1,1,1,1,7),vzx,alpha,beta,n,'wx2m',ifverbose)
        call avg2(rux2(1,1,1,1,8),vzy,alpha,beta,n,'wy2m',ifverbose)
        call avg2(rux2(1,1,1,1,9),vzz,alpha,beta,n,'wz2m',ifverbose)

        call avg2(rux2(1,1,1,1,10),tx ,alpha,beta,n,'tx2m',ifverbose)
        call avg2(rux2(1,1,1,1,11),ty ,alpha,beta,n,'ty2m',ifverbose)
        call avg2(rux2(1,1,1,1,12),tz ,alpha,beta,n,'tz2m',ifverbose)

      endif ! (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 )
c     ############################################################
      timel = time

      if (istep.gt.0 .and. mod(istep,int(iostep_2d_avg_time)).eq.0) then
c     ############################################################
c     spanwise averaging
        do i =1,12
          call planar_avg(suxm(1,1,1,1,i),ruxm(1,1,1,1,i),igs_x) !x averaging
          call planar_avg(sux2(1,1,1,1,i),rux2(1,1,1,1,i),igs_x) !x averaging
        enddo
        do i =1,6
          call planar_avg(suvm(1,1,1,1,i),ruvm(1,1,1,1,i),igs_x) !x averaging
        enddo
        do i =1,4
          call planar_avg(summ(1,1,1,1,i),rumm(1,1,1,1,i),igs_x) !x averaging
          call planar_avg(su2m(1,1,1,1,i),ru2m(1,1,1,1,i),igs_x) !x averaging
        enddo

        if(nid.eq.0) then
         write(istepc,'(i32)') istep
         istepc=adjustl(istepc)
         icfile=trim('means.'//trim(istepc))
         open(unit=58,file=icfile,form='unformatted')
         do i=1,4
           call copy(wo1,summ(1,1,1,1,i),n)
           call x_slice(w4,wo1,w1,w2)
           write(58) w4
         enddo
         do i=1,4
           call x_slice(w4,su2m(1,1,1,1,i),w1,w2)
           write(58) w4
         enddo
         do i=1,6
           call x_slice(w4,suvm(1,1,1,1,i),w1,w2)
           write(58) w4
         enddo
         do i=1,12
           call x_slice(w4,suxm(1,1,1,1,i),w1,w2)
           write(58) w4
         enddo
         do i=1,12
           call x_slice(w4,suxm(1,1,1,1,i),w1,w2)
           write(58) w4
         enddo
         close(58)
        endif
      

        if (nid.eq.0)then
          open(unit=12,file='test2du.dat')
          call x_slice(w4,summ(1,1,1,1,i),w1,w2) !w4(ly1,lz1,lely,lelz)
          do i=1,nely
            do j=1,nelz
              write(12,*)(w4(k,1,i,j), k=1,ny1*nz1)
            enddo
          enddo
          close(12)
        endif 

      endif

C         if(restart_means.eq.1 .and. istep.eq.iostep_2d_avg_time) then   !if the last restart file was written during the current session, don't read it and keep on time averaging
C           call input_means(stat_old,time_old) !placeholder, fix this asap. time old should be the total time used for those means
C           t_new=time !assumes time_start=0
C           t_tot=t_new+t_old
C           alpha=t_new/t_tot
C           beta =t_old/t_tot
C           do i =1,nstat
C           call avg1(stat(1,i),stat_old(1,i),alpha,beta,n,'    ',.false.) !time averaging (n? shouldn't it be m?)
C           enddo
C         endif
C         call write_means(stat) !placeholder, fix this asap


c     ############################################################
c     COMPUTE HYDROSTATIC PRESSURE (AVERAGE OF TEMP(y))
c     FOR REFERENCE ON THIS TERM SEE CANTERO 2009 JGR
c
      mn=ny1*nely
      call rzero(tempbar,mn)
      call planar_avg(wo1,t(1,1,1,1,1),igs_z)  !wo1,2(lx1,ly1,lz1,lelv)
      call planar_avg(wo2,wo1,igs_z)
      call y_line(tempbar,wo2,w1t,w2t)
      
c
c     ############################################################

      return
      end

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TSTEP'
      include 'PARALLEL'
      include 'NEKUSE'

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      parameter(nel_slab = nelxin*nelyin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)

c     ############################################################


c     ############################################################
c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      ux   = 0.
      uy   = 0.
      uz   = 0.
      temp = 0.

      if (ifield .eq. 1) then               ! velocity
        if(ieg.le.nel_slab.and.iside.eq.5) then
c          ux  = vxin_pl(ix,iy,ieg)
c          uy  = vyin_pl(ix,iy,ieg)
c          uz  = vzin_pl(ix,iy,ieg)
        endif
      elseif (ifield .eq. 2) then     !temperature
        temp = 0.0
        if (ieg.le.nel_slab.and.iside.eq.5) then  
c          temp  = tin_pl(ix,iy,ieg)
        endif
      endif
c     ############################################################
c     ############################################################

      return
      end

      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
C       subroutine usrdat
C       include 'SIZE'
C       include 'TOTAL'
      
C       integer n,nelyint,nelytot,mmnely
C       real hfh,hfint,amp,delyi,rrleny,rrlenyint,y

C       n=8*nelt
C c
C       nelyint = 30
C       nelytot = 44          !<------------ CHANGE! nely in big domain

C       delyi =hf/nelyi
C       rrleny = nelytot*delyi 
C       rrlenyint = nelyint*delyi
C       hfh=hf/2.0
C       hfint = rrlenyint
C       amp = (ASINH((4.0/6.0)*SINH(-3.25)))/(-0.7*3.25)

C       do i=1,n
C         yc(i,1)  = rrleny * yc(i,1) 
C         y=yc(i,1)

C         if (y.le.hfh) then
C           yc(i,1) = (-1)*(1-SINH(3.25*y)/SINH(3.25))+1
C         elseif (y.le.hf) then
C           yc(i,1) = (1)*(1 - SINH(3.25*(2-y))/SINH(3.25))+1
C         elseif (y.le.hfint) then
C           y = y / rrlenyint
C           yc(i,1)= (6*SINH(3.25*amp*(0.3-y))/SINH(-3.25))+2
C         elseif (y.gt.hfint) then
C           y = y/rrleny
C           yc(i,1)=y*nelytot-24
C         endif
C         xc(i,1) =  XLEN * xc(i,1)
C c        xc(i,1) =  2.0 * PI * xc(i,1)
C         zc(i,1) = ZLEN * zc(i,1)
C       enddo

C       return
C       end
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      
      integer n,nelyi,nelyint,nelytot,mmnely
      real one,hf,hfh,hfint,amp,delyi,rrleny,rrlenyint,y

      n=8*nelt
c
      hf = 2.0             !<------------ CHANGE! Height of inflow domain
      nelyi = 9            !<------------ CHANGE! nely of inflow domain
      nelyint = 30
      nelytot = 44          !<------------ CHANGE! nely in big domain

      delyi =hf/nelyi
      rrleny = nelytot*delyi 
      rrlenyint = nelyint*delyi
      hfh=hf/2.0
      hfint = rrlenyint
      amp = (ASINH((4.0/6.0)*SINH(-3.25)))/(-0.7*3.25)

      do i=1,n
        yc(i,1)  = rrleny * yc(i,1) 
        y=yc(i,1)

        if (y.le.hfh) then
          yc(i,1) = (-1)*(1-SINH(3.25*y)/SINH(3.25))+1
        elseif (y.le.hf) then
          yc(i,1) = (1)*(1 - SINH(3.25*(2-y))/SINH(3.25))+1
        elseif (y.le.hfint) then
          y = y / rrlenyint
          yc(i,1)= (6*SINH(3.25*amp*(0.3-y))/SINH(-3.25))+2
        elseif (y.gt.hfint) then
          y = y/rrleny
          yc(i,1)=y*nelytot-24
        endif
        xc(i,1) =  (8.0/3.0)*pi * xc(i,1)
c        xc(i,1) =  2.0 * pi * xc(i,1)
        zc(i,1) = 32.0 * pi * zc(i,1)
      enddo

      return
      end
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
      
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end

c-----------------------------------------------------------------------
      subroutine planar_inflow(ua,u,mnelin,w1)
c
c     Compute r-s planar average of quantity u()
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      integer e,eg,mnelin,nxyin
      real u(nx1*ny1,mnelin),aindum(nx1*ny1,mnelin)
      real ain(nx1*ny1,mnelin),ua,uadum,w1,w1dum
c
c     As the numbering of elements in a single box
c     go in the order of r-s-t (first fill r, then 
c     s and then t) the ordering of the 2d elements 
c     in u (2d inlet) is the same as the first 
c     t-plane of elements in the 3d box. Hence,
c     face 5 of the first mnelin elements of the 
c     3dbox have the same area as the 2d inlet.

      nxyin = nx1*ny1*mnelin
      call rzero(ain,nxyin)
      call rzero(aindum,nxyin)
      do e=1,nelt
c        l local gl global el element
         eg = lglel(e)
         if (eg.le.mnelin) then
           do i=1,nx1*ny1
              aindum(i,eg) = area(i,1,5,e)
           enddo
         endif
      enddo
      call gop(aindum,ain,'+  ',nxyin)

      ua=0.0
      uadum=0.0
      w1=0.0
      w1dum=0.0

      if (nid.eq.0) then
       do e=1,mnelin
          do i=1,nx1*ny1
            w1dum = w1dum + ain(i,e)
            uadum = uadum + ain(i,e)*u(i,e)
          enddo
       enddo
       uadum = uadum / w1dum ! Normalize
      endif
      call gop(uadum,ua,'+  ',1)      
      call gop(w1dum,w1,'+  ',1)      


      return
      end

c----------------------------------------------------------------
      subroutine interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin1,z_inflow,rlenz
     $          ,dtimestep,restart_inflow1)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer step_inflow,nelzin1,nel_slab,nelin
      integer restart_inflow1
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)



      real zz(nz1,nelz),w1(nz1,nelz),w2(nz1,nelz)
      real zzin(nz1,nelzin1)
      integer nzin,flagin,e,m

      real vzinavg,uadum,w1in,z_sup,z_inf
      integer k_sup,k_inf,ez_in,e_pl

      real vxin_pl_dum(lx1,ly1,nel_slab)
     $    ,vyin_pl_dum(lx1,ly1,nel_slab)
     $    ,vzin_pl_dum(lx1,ly1,nel_slab)
     $    ,tin_pl_dum(lx1,ly1,nel_slab)

      real z_inflow_dum

c     ---------------------------------------------------------
      m = nx1*ny1*nel_slab
      call planar_average_z(zz,zm1,w1,w2)
      nzin=nelzin1*nz1
      call copy(zzin,zz,nzin)
      if (istep.eq.0.and.restart_inflow1.eq.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
         z_inflow = rlenz
         do e=1,nel_slab
          e_pl = nel_slab*(nelzin1-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e) = vxin(i,j,nz1,e_pl)
              vyin_pl(i,j,e) = vyin(i,j,nz1,e_pl)
              vzin_pl(i,j,e) = vzin(i,j,nz1,e_pl)
              tin_pl(i,j,e) = tin(i,j,nz1,e_pl)
            enddo
          enddo
         enddo

      elseif (istep.eq.0.and.restart_inflow1.eq.1) then
c       This part has to be done by only nid.eq.0
c       (could generate reading issues otherwise)
        z_inflow = 0.0
        z_inflow_dum = 0.0
        call rzero(vxin_pl,m)
        call rzero(vyin_pl,m)
        call rzero(vzin_pl,m)
        call rzero(tin_pl,m)
        call rzero(vxin_pl_dum,m)
        call rzero(vyin_pl_dum,m)
        call rzero(vzin_pl_dum,m)
        call rzero(tin_pl_dum,m)
        if (nid.eq.0) then
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART ####'
          open(unit=58,file='inflow2d.ini',form='unformatted')
          read(58) z_inflow_dum
          read(58) vxin_pl_dum,vyin_pl_dum,vzin_pl_dum,tin_pl_dum
          close(58)
          write(*,*)'FILE: inflow2d.ini'
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART DONE ###'
        endif
        call gop(z_inflow_dum,z_inflow,'+  ',1)
        call gop(vxin_pl_dum,vxin_pl,'+  ',m)
        call gop(vyin_pl_dum,vyin_pl,'+  ',m)
        call gop(vzin_pl_dum,vzin_pl,'+  ',m)
        call gop(tin_pl_dum,tin_pl,'+  ',m)

      elseif (istep.gt.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
        call planar_inflow(vzinavg,vzin_pl,nel_slab,w1in)
       
        dz_inflow = dtimestep * vzinavg
        if (z_inflow.lt.dz_inflow) then
          z_inflow = rlenz - (dz_inflow - z_inflow)
        else
          z_inflow = z_inflow - dz_inflow
        endif


        flagin=0
        do e=nelzin1,1,-1
          do k=nz1,1,-1
            if (z_inflow.gt.zzin(k,e).and.flagin.eq.0) then
              z_sup = zzin(k+1,e)
              z_inf = zzin(k,e)
              k_sup = k+1
              k_inf = k
              ez_in = e
              flagin=1
            endif
          enddo
        enddo

        do e=1,nel_slab
          e_pl = nel_slab*(ez_in-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e)=((vxin(i,j,k_sup,e_pl)-
     $                       vxin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vxin(i,j,k_inf,e_pl)

              vyin_pl(i,j,e)=((vyin(i,j,k_sup,e_pl)-
     $                       vyin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vyin(i,j,k_inf,e_pl)

              vzin_pl(i,j,e)=((vzin(i,j,k_sup,e_pl)-
     $                       vzin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vzin(i,j,k_inf,e_pl)

              tin_pl(i,j,e) =((tin(i,j,k_sup,e_pl)-
     $                       tin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       tin(i,j,k_inf,e_pl)
            enddo
          enddo
        enddo

      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine x_slice (ua,u,w1,w2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nz1,nely,nelz),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nz1,nely,nelz),w2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      write(*,*)'pato31'
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w2,'+  ',myz)

      return
      end
c---------------------------------------------------------------------      
      subroutine y_line (ua,u,w1,w2)
c
c     Extract a y slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
      real dy2
c
      my = nely*ny1
      call rzero(ua,my)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1) then
            do j=1,ny1
               ua(j,ey) = u(i,j,k,e)
            enddo
         endif
      enddo
      call gop(ua,w2,'+  ',my)

      return
      end

c     ##################################################################
      subroutine planar_average_s(ua,u,w1,w2)
c
c     Compute r-t planar average of quantity u()
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelt),w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
c     
      ny = ny1*nely
      call rzero(ua,ny)
      call rzero(w1,ny)
c
      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
c    
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1
            zz = (1.-zgm1(j,2))/2.  ! = 1 for i=1, = 0 for k=nx1
            aa = zz*area(i,k,1,e) + (1-zz)*area(i,k,3,e)  ! wgtd jacobian
            w1(j,ey) = w1(j,ey) + aa
            ua(j,ey) = ua(j,ey) + aa*u(i,j,k,e)
         enddo
         enddo
         enddo
      enddo
c
      call gop(ua,w2,'+  ',ny)
      call gop(w1,w2,'+  ',ny)
c
      do i=1,ny
         ua(i,1) = ua(i,1) / w1(i,1)   ! Normalize
      enddo

      return
      end

c     ##############################################################


c     ############################################################
      subroutine output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl
     $                           ,nel_slab,z_inflow)
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z_inflow
      integer nel_slab

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)

      character*80 istepc_inflow,icfile_inflow
c    ----------------------------------------------------------

      if (nid.eq.0) then
        write(istepc_inflow,'(i32)') istep
        istepc_inflow=adjustl(istepc_inflow)
        icfile_inflow=trim('inflow2d'//'.'//trim(istepc_inflow))
        open(unit=58,file=icfile_inflow,form='unformatted')
        write(58) z_inflow
        write(58) vxin_pl,vyin_pl,vzin_pl,tin_pl
        close(58)
      endif

      return
      end
c----------------------------------------------------------------------

      subroutine read_inflow(vxin,vyin,vzin,tin,nelin,nin)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelin,nin

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)


      real dum(nx1,ny1,nz1,nelin)
      character*80 icfile
c     -----------------------------------------------------

      call rzero(vxin,nin)
      call rzero(vyin,nin)
      call rzero(vzin,nin)
      call rzero(tin,nin)
      do k=1,4 !only works with 3d TC
c      Zero all dummy arrays
       call rzero(dum,nin)
c      Read IC file
       if (nid.eq.0) then
         if(k.eq.1) icfile=trim('vx_inflow.ini')
         if(k.eq.2) icfile=trim('vy_inflow.ini')
         if(k.eq.3) icfile=trim('vz_inflow.ini')
         if(k.eq.4) icfile=trim('temp_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,status='old', ACCESS='stream')
         read(58) dum
         close(58)
       endif
c      Add across all processors (dum --> vxin)
       if(k.eq.1) call gop(dum,vxin,'+  ',nin)
       if(k.eq.2) call gop(dum,vyin,'+  ',nin)
       if(k.eq.3) call gop(dum,vzin,'+  ',nin)
       if(k.eq.4) call gop(dum,tin,'+  ',nin)
      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine planar_average_z(ua,u,w1,w2)
c
c     Compute r-s planar average of quantity u() USED IN INTERPOLATE INFLOW
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nz1,nelz),u(nx1*ny1,nz1,nelv),w1(nz1,nelz),w2(nz1,nelz)
      integer e,eg,ez
c
      melxy = nelx*nely
c
      nz = nz1*nelz
      call rzero(ua,nz)
      call rzero(w1,nz)
c
      do e=1,nelt
c
         eg = lglel(e)
         ez = 1 + (eg-1)/melxy
c
         do k=1,nz1
         do i=1,nx1*ny1
            zz = (1.-zgm1(k,3))/2.  ! = 1 for k=1, = 0 for k=nz1
            aa = zz*area(i,1,5,e) + (1-zz)*area(i,1,6,e)  ! wgtd jacobian
            w1(k,ez) = w1(k,ez) + aa
            ua(k,ez) = ua(k,ez) + aa*u(i,k,e)
         enddo
         enddo
      enddo
c
      call gop(ua,w2,'+  ',nz)
      call gop(w1,w2,'+  ',nz)
c
      do i=1,nz
         ua(i,1) = ua(i,1) / w1(i,1)   ! Normalize
      enddo
c
      return
      end

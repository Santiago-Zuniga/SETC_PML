c- constants -----------------------------------------------------------

#define iostep_2d_avg_time  uparam(1) /* output frequency for statistics */
#define VISCFAC uparam(2)             /* viscosity multiplier at ouflow */
#define RITAU uparam(3)               /* Ri_tau */
#define UTARGET uparam(4)             /* u_target for top PML, positive */ 
#define restart_inflow uparam(5)      /* whether to read inflow2d.ini (2d) for restasting */
#define iostep_inflow uparam(6)       /* frequency of output for inflow2d file */
#define delta_fltr uparam(7)          /* integration filter limit */
#define restart_means uparam(8)       /* Restart of means flag (reads means.ini binary files) */

#define RE_TAU (1/param(2))
c - mesh and buffer zones dimensions
#define PI (4.*atan(1.))
#define ZLEN (32.*PI)
#define XLEN (8.*PI/3.)
#define YLEN 20.
#define ZBUFF (ZLEN-PI)
#define YBUFF 12.

c - Iflow dimensions
#define nelxin 15 /*number of elements of inflow array */
#define nelyin 9
#define nelzin 28
#define hf 2.0 /*height of inflow domain*/


      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     TURBULENT OUTFLOW
c     Sets low Re number in range [zout;lenz]
c
      zout = ZLEN-PI                               !<----------CHANGE!
      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)
         if (z.ge.zout) then
           udiff =((param(2)*VISCFAC - param(2))/(ZLEN-zout))
     $            *(z-zout) + param(2)
         endif
      else if(ifield.eq.2)then                    ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (z.ge.zout) then
          udiff =((param(8)*VISCFAC - param(8))/(ZLEN-zout))
     $           *(z-zout) + param(8)
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz


      real*8 egrav(3)

c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lely)
     &             ,w1t(ly1,lely)
     &             ,w2t(ly1,lely)
c
      integer ex,ey,ez

c     BUFFER ZONE VARIABLES
      real*8 sigma(3),sigmam1(3),sigmam2(3),beta,ybuff
     $        ,zbuff,umean1(3),umean2(3),yy,zz,m,vzout

c     MESH VARIABLES
      egrav(1) = 0.0                !x: Spanwise direction
      egrav(2) = (-1)*RITAU         !y: Wall-normal direction
      egrav(3) = 1.0                !z: Streamwise direction

c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
      call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

      ffx = temp*egrav(1)
      ffy = (temp - tempbar(iy,ey))*egrav(2)
      ffz = temp*egrav(3)
c     ############################################################
c     ############################################################

c     ############################################################
c     ############################################################
c     Buffer zones
      sigmam1(1) = 0.0                          !<-----------------CHANGE!
      sigmam1(2) = 1.0                          !<-----------------CHANGE!
      sigmam1(3) = 0.0                          !<-----------------CHANGE!

      sigmam2(1) = 0.0                          !<-----------------CHANGE!
      sigmam2(2) = 0.0                          !<-----------------CHANGE!
      sigmam2(3) = 0.0                          !<-----------------CHANGE!

      beta = 2.0                                !<-----------------CHANGE!

      umean1(1) = 0.0                           !<-----------------CHANGE! 
      umean1(2) =-UTARGET                       
      umean1(3) = 0.0                           !<-----------------CHANGE! 
      
      umean2(1) = 0.0                           !<-----------------CHANGE! 
      umean2(2) = 0.0                           !<-----------------CHANGE! 
      umean2(3) = 0.0                           !<-----------------CHANGE! 

      m = (YLEN-YBUFF)/(ZLEN-ZBUFF)
      zz = (y-YBUFF)/m + ZBUFF
      yy = m * (z-ZBUFF) + YBUFF

c     ###############
c     Top buffer zone
      sigma(1) = 0.0
      sigma(2) = 0.0
      sigma(3) = 0.0
      if (y.ge.YBUFF.and.z.le.zz) then
        sigma(1) = sigmam1(1)*((y - YBUFF)/(YLEN-YBUFF))**(beta)
        sigma(2) = sigmam1(2)*((y - YBUFF)/(YLEN-YBUFF))**(beta)
        sigma(3) = sigmam1(3)*((y - YBUFF)/(YLEN-YBUFF))**(beta)

        ffx = ffx - sigma(1) * (ux - umean1(1))
        ffy = ffy - sigma(2) * (uy - umean1(2)) 
        ffz = ffz - sigma(3) * (uz - umean1(3))
      endif

c     ###################
c     Outflow buffer zone
      if(.FALSE.) then
          sigma(1) = 0.0
          sigma(2) = 0.0
          sigma(3) = 0.0
          all get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          vzout = vzout_pl(ix,iy,ex,ey)
          if (z.ge.ZBUFF.and.y.lt.yy.and.vzout.lt.0.0) then
            sigma(1) = sigmam2(1)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)
            sigma(2) = sigmam2(2)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)
            sigma(3) = sigmam2(3)*((z - ZBUFF)/(ZLEN - ZBUFF))**(beta)

            ffx = ffx - sigma(1) * (ux - umean2(1))
            ffy = ffy - sigma(2) * (uy - umean2(2))
            ffz = ffz - sigma(3) * (uz - umean2(3))
          endif
      endif
c     ####################
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)
 
      qvol   = 0.0
      source = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

c     ############################################################
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
      integer nelin,nel_slab,nin
      real rlenz,z_inflow,dz_inflow
      real dtimestep
      integer set_IC_flag

c     If set_IC_flag.eq.1 copy inflow file at bottom of big domain
      parameter(set_IC_flag=0)                           !<----- CHANGE!

      parameter(nelin=nelxin*nelyin*nelzin)
      parameter(nel_slab=nelxin*nelyin)
      parameter(nin = nelin*lx1*ly1*lz1)

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)
      save z_inflow

c     ############################################################
c     DEPTH-AVERAGED STATISTICS VARIABLES

c     Output frequency of span-time-averaged .fld files
c     and means.* binary files

c     Output frequency of span-averaged .fld files
      integer iostep_2d
      parameter( iostep_2d= 1000 )          !<-----------CHANGE!

c     Integration filter: The moments of velocity and concentration
c     are computed from z=0 to z=z_delta_fltr where z_delta_fltr
c     is the wall-normal location where we find a concentration
c     c<=delta_fltr


      real timem,atimem,timelm,dtimem

c     spanwise-averaged arrays
      real    yavgx(ny1,nz1,lely,lelz)
     $    ,   zavgx(ny1,nz1,lely,lelz)

c     spanwise-averaged arrays
C       common /avg2dtime/ 
C      $        uavgx(ly1,lz1,lely,lelz)
C      $    ,   vavgx(ly1,lz1,lely,lelz)
C      $    ,   wavgx(ly1,lz1,lely,lelz)
C      $    ,   tavgx(ly1,lz1,lely,lelz)
C      $    ,   w1(ly1,lz1,lely,lelz)
C      $    ,   w2(ly1,lz1,lely,lelz)
C      $    ,   u2avgx(ly1,lz1,lely,lelz)
C      $    ,   v2avgx(ly1,lz1,lely,lelz)
C      $    ,   w2avgx(ly1,lz1,lely,lelz)
C      $    ,   t2avgx(ly1,lz1,lely,lelz)
C      $    ,   uvavgx(ly1,lz1,lely,lelz)
C      $    ,   uwavgx(ly1,lz1,lely,lelz)
C      $    ,   utavgx(ly1,lz1,lely,lelz)
C      $    ,   vwavgx(ly1,lz1,lely,lelz)
C      $    ,   vtavgx(ly1,lz1,lely,lelz)
C      $    ,   wtavgx(ly1,lz1,lely,lelz)
C      $    ,   uxavgx(ly1,lz1,lely,lelz)
C      $    ,   uyavgx(ly1,lz1,lely,lelz)
C      $    ,   uzavgx(ly1,lz1,lely,lelz)
C      $    ,   vxavgx(ly1,lz1,lely,lelz)
C      $    ,   vyavgx(ly1,lz1,lely,lelz)
C      $    ,   vzavgx(ly1,lz1,lely,lelz)
C      $    ,   wxavgx(ly1,lz1,lely,lelz)
C      $    ,   wyavgx(ly1,lz1,lely,lelz)
C      $    ,   wzavgx(ly1,lz1,lely,lelz)
C      $    ,   txavgx(ly1,lz1,lely,lelz)
C      $    ,   tyavgx(ly1,lz1,lely,lelz)
C      $    ,   tzavgx(ly1,lz1,lely,lelz)
C      $    ,   ux2avgx(ly1,lz1,lely,lelz)
C      $    ,   uy2avgx(ly1,lz1,lely,lelz)
C      $    ,   uz2avgx(ly1,lz1,lely,lelz)
C      $    ,   vx2avgx(ly1,lz1,lely,lelz)
C      $    ,   vy2avgx(ly1,lz1,lely,lelz)
C      $    ,   vz2avgx(ly1,lz1,lely,lelz)
C      $    ,   wx2avgx(ly1,lz1,lely,lelz)
C      $    ,   wy2avgx(ly1,lz1,lely,lelz)
C      $    ,   wz2avgx(ly1,lz1,lely,lelz)
C      $    ,   tx2avgx(ly1,lz1,lely,lelz)
C      $    ,   ty2avgx(ly1,lz1,lely,lelz)
C      $    ,   tz2avgx(ly1,lz1,lely,lelz)
      parameter(nstat=38)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat2d(ly1,lz1,lely,lelz,nstat)
      save ravg, stat, stat2d
      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      real             w1(ly1,lz1,lely,lelz)
     $              ,   w2(ly1,lz1,lely,lelz)
     &              ,  w3(ly1,lz1,lely,lelz)

      save igs_x

c     perturbations
C       real    up2avgx(ly1,lz1,lely,lelz)
C      $    ,   vp2avgx(ly1,lz1,lely,lelz)
C      $    ,   wp2avgx(ly1,lz1,lely,lelz)
C      $    ,   tp2avgx(ly1,lz1,lely,lelz)
C      $    ,   uvpavgx(ly1,lz1,lely,lelz)
C      $    ,   uwpavgx(ly1,lz1,lely,lelz)
C      $    ,   utpavgx(ly1,lz1,lely,lelz)
C      $    ,   vwpavgx(ly1,lz1,lely,lelz)
C      $    ,   vtpavgx(ly1,lz1,lely,lelz)
C      $    ,   wtpavgx(ly1,lz1,lely,lelz)
C      $    ,   uxp2avgx(ly1,lz1,lely,lelz)
C      $    ,   uyp2avgx(ly1,lz1,lely,lelz)
C      $    ,   uzp2avgx(ly1,lz1,lely,lelz)
C      $    ,   vxp2avgx(ly1,lz1,lely,lelz)
C      $    ,   vyp2avgx(ly1,lz1,lely,lelz)
C      $    ,   vzp2avgx(ly1,lz1,lely,lelz)
C      $    ,   wxp2avgx(ly1,lz1,lely,lelz)
C      $    ,   wyp2avgx(ly1,lz1,lely,lelz)
C      $    ,   wzp2avgx(ly1,lz1,lely,lelz)
C      $    ,   txp2avgx(ly1,lz1,lely,lelz)
C      $    ,   typ2avgx(ly1,lz1,lely,lelz)
C      $    ,   tzp2avgx(ly1,lz1,lely,lelz)
C      $    ,   kavgx(ly1,lz1,lely,lelz)
C      $    ,   prodavgx(ly1,lz1,lely,lelz)
C      $    ,   dissavgx(ly1,lz1,lely,lelz)
C      $    ,   rigavgx(ly1,lz1,lely,lelz)
C      $    ,   urmsavgx(ly1,lz1,lely,lelz)
C      $    ,   vrmsavgx(ly1,lz1,lely,lelz)
C      $    ,   wrmsavgx(ly1,lz1,lely,lelz)
C      $    ,   trmsavgx(ly1,lz1,lely,lelz)

C c     spanwise-averaged arrays for shape functions
C       real    eta_fltr(ny1,nz1,lely,lelz)
C      $    ,   wavgx_w_fltr(ny1,nz1,lely,lelz)
C      $    ,   tavgx_t_fltr(ny1,nz1,lely,lelz)
C      $    ,   kavgx_k_fltr(ny1,nz1,lely,lelz)
C      $    ,   vwpavgx_w2_fltr(ny1,nz1,lely,lelz)
C      $    ,   vtpavgx_wt_fltr(ny1,nz1,lely,lelz)
C      $    ,   prodavgx_hw3_fltr(ny1,nz1,lely,lelz)
C      $    ,   dissavgx_hw3_fltr(ny1,nz1,lely,lelz)
C c
C c     spanwise-averaged arrays (non-time averaged)
C       real    uavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   tavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   u2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   v2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   w2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   t2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uvavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uwavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   utavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vwavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vtavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wtavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uxavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uyavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uzavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vxavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vyavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vzavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wxavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wyavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wzavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   txavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   tyavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   tzavgx_notime(ly1,lz1,lely,lelz)
C      $    ,   ux2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uy2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   uz2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vx2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vy2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   vz2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wx2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wy2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   wz2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   tx2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   ty2avgx_notime(ly1,lz1,lely,lelz)
C      $    ,   tz2avgx_notime(ly1,lz1,lely,lelz)

c     depth-averaged arrays
      real zavgxy(nz1,lelz)

c     depth-averaged arrays
      real uavgxy(nz1,lelz)
     $    ,vavgxy(nz1,lelz)
     $    ,wavgxy(nz1,lelz)
     $    ,tavgxy(nz1,lelz)
     $    ,w2avgxy(nz1,lelz)
     $    ,wtavgxy(nz1,lelz)
     $    ,wkavgxy(nz1,lelz)
     $    ,prodavgxy(nz1,lelz)
     $    ,dissavgxy(nz1,lelz)

c     depth-averaged arrays (filtered)
      real    uavgxy_fltr(nz1,lelz)
     $       ,vavgxy_fltr(nz1,lelz)
     $       ,wavgxy_fltr(nz1,lelz)
     $       ,tavgxy_fltr(nz1,lelz)
     $       ,w2avgxy_fltr(nz1,lelz)
     $       ,wtavgxy_fltr(nz1,lelz)
     $       ,wkavgxy_fltr(nz1,lelz)
     $       ,prodavgxy_fltr(nz1,lelz)
     $       ,dissavgxy_fltr(nz1,lelz)
c

c     dWh/dz (from cons. of mass dUh/dz=we)
      real    dzwavgxy(nz1,lelz),
     $        dzwavgxy_fltr(nz1,lelz)
c
c     Interface position array (intr) and threshold delta
      real intr(nz1,lelz)

c     average in time variables
      integer icalled
      save    icalled
      data    icalled /0/

      real atime,timel
      save atime,timel
      real alpha,beta
      logical ifverbose
      integer n,nt

      integer icnt_time
      save    icnt_time
      data    icnt_time /0/

      integer icnt
      save    icnt
      data    icnt /0/
c
      character*32 istepc,outfile

      character*80 icfile
c
c     Gradient arrays for shear velocity, 
c     tke production and dissipation computation
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vyx(lx1,ly1,lz1,lelv),
     $     vyy(lx1,ly1,lz1,lelv),
     $     vyz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv),
     $     tx(lx1,ly1,lz1,lelv),
     $     ty(lx1,ly1,lz1,lelv),
     $     tz(lx1,ly1,lz1,lelv)

      real t_tot, t_old, t_new
c     ############################################################
c
c     ############################################################
c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lely)
     $             ,w1t(ly1,lely)
     $             ,w2t(ly1,lely)
c
cc     ############################################################
cc     BUFFER REGION VARIABLES (by JS, has not been modified)
c      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)
c      real vzout_pldum(lx1,ly1,lelx,lely)
c      integer ex,ey,ez,eg
c      integer iostep_outflow,iostep_outflow_notime
c      real vmax,vmaxdum,zmax,wmin,wmindum,ymin
c
cc     Output frequency of outflow boundaries statistics    
c      parameter(iostep_outflow = 1000)               !<----- CHANGE!
c      parameter(iostep_outflow_notime = 1000)        !<----- CHANGE!
cc     ############################################################

c     ############################################################
c
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
c
c     This code is made for a mesh composed of only one box.
c     Computes the inlet boundary condition for the next time step
c     interpolating the solution for a TC with fixed mean 
c     streamwise velocity and concentration

      dtimestep = abs(PARAM(12))
c     READ INFLOW
      if (istep.eq.0) then
        call read_inflow(vxin,vyin,vzin,tin,nelin,nin)
        if (set_IC_flag.eq.1) then
          call set_IC(vxin,vyin,vzin,tin,nelin,nelxin,nelyin,nelzin
     $               ,nel_slab)
        endif
      endif

      call interpolate_inflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow,ZLEN
     $          ,dtimestep,restart_inflow)

      if (mod(istep,iostep_inflow).eq.0) then
        call output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl,nel_slab
     $                       ,z_inflow)
      endif
c     ############################################################
c     OUTPUT INITIAL CONDITION
      if (istep.eq.0) then
        ifxyo = .true.
        call prepost(.true.,'   ' )
        ifxyo = .false.
      endif
c     ############################################################
      n=nx1*ny1*nz1*nelv  
      nt=nx1*ny1*nz1*nelt
      m=ny1*nz1*nely*nelz
c
      if(icalled.eq.0) then
        call rzero(ravg,size(ravg))
        call gtpp_gs_setup(igs_x,nelx     ,nely,nelz,1) ! x-avx
        atime = 0.
        timel = time
        icalled = 1
C         dtime = time - timel
C         atime = atime + dtime
c      elseif()!check when to read previous means

      endif !(icalled.eq.0.and.restart_means.eq.0)
      dtime = time - timel
      atime = atime + dtime
c     ############################################################

c     compute gradients
      call gradm1(vxx,vxy,vxz,vx)
      call gradm1(vyx,vyy,vyz,vy)
      call gradm1(vzx,vzy,vzz,vz)
      call gradm1(tx,ty,tz,t(1,1,1,1,1))
c     ############################################################
c     averaging over time
      if (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 ) then
        beta      = dtime / atime
        alpha     = 1. - beta

        ifverbose = .false.
c       Compute time-average of u,v,w and t       
        call avg1(ravg(1,1),vx,alpha,beta,n,'uavg',ifverbose)
        call avg1(ravg(1,2),vy,alpha,beta,n,'vavg',ifverbose) 
        call avg1(ravg(1,3),vz,alpha,beta,n,'wavg',ifverbose) 
        call avg1(ravg(1,4),t, alpha,beta,n,'tavg',ifverbose)

c       Compute time-average of u^2,v^2,w^2 and t^2     
        call avg2(ravg(1,5),vx,alpha,beta,n,'u2mm',ifverbose)
        call avg2(ravg(1,6),vy,alpha,beta,n,'v2mm',ifverbose) 
        call avg2(ravg(1,7),vz,alpha,beta,n,'w2mm',ifverbose) 
        call avg2(ravg(1,8),t ,alpha,beta,n,'t2mm',ifverbose)

c       Compute time-average of cross products
        call avg3(ravg(1,9 ),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg3(ravg(1,10),vx,vz,alpha,beta,n,'uwmm',ifverbose)
        call avg3(ravg(1,11),vx, t,alpha,beta,n,'utmm',ifverbose)
        call avg3(ravg(1,12),vy,vz,alpha,beta,n,'vwmm',ifverbose)
        call avg3(ravg(1,13),vt, t,alpha,beta,n,'vtmm',ifverbose)
        call avg3(ravg(1,14),vz, t,alpha,beta,n,'wtmm',ifverbose)

c       Compute time-average of gradients     
        call avg1(ravg(1,15),vxx,alpha,beta,n,'uxmm',ifverbose)
        call avg1(ravg(1,16),vxy,alpha,beta,n,'uymm',ifverbose)
        call avg1(ravg(1,17),vxz,alpha,beta,n,'uzmm',ifverbose)

        call avg1(ravg(1,18),vyx,alpha,beta,n,'vxmm',ifverbose)
        call avg1(ravg(1,19),vyy,alpha,beta,n,'vymm',ifverbose)
        call avg1(ravg(1,20),vyz,alpha,beta,n,'vzmm',ifverbose)

        call avg1(ravg(1,21),vzx,alpha,beta,n,'wxmm',ifverbose)
        call avg1(ravg(1,22),vzy,alpha,beta,n,'wymm',ifverbose)
        call avg1(ravg(1,23),vzz,alpha,beta,n,'wzmm',ifverbose)

        call avg1(ravg(1,24),tx ,alpha,beta,n,'txmm',ifverbose)
        call avg1(ravg(1,25),ty ,alpha,beta,n,'tymm',ifverbose)
        call avg1(ravg(1,26),tz ,alpha,beta,n,'tzmm',ifverbose)

c       Compute time-average of squared gradients
        call avg2(ravg(1,27),vxx,alpha,beta,n,'ux2m',ifverbose)
        call avg2(ravg(1,28),vxy,alpha,beta,n,'uy2m',ifverbose)
        call avg2(ravg(1,29),vxz,alpha,beta,n,'uz2m',ifverbose)

        call avg2(ravg(1,30),vyx,alpha,beta,n,'vx2m',ifverbose)
        call avg2(ravg(1,31),vyy,alpha,beta,n,'vy2m',ifverbose)
        call avg2(ravg(1,32),vyz,alpha,beta,n,'vz2m',ifverbose)

        call avg2(ravg(1,33),vzx,alpha,beta,n,'wx2m',ifverbose)
        call avg2(ravg(1,34),vzy,alpha,beta,n,'wy2m',ifverbose)
        call avg2(ravg(1,35),vzz,alpha,beta,n,'wz2m',ifverbose)

        call avg2(ravg(1,36),tx ,alpha,beta,n,'tx2m',ifverbose)
        call avg2(ravg(1,37),ty ,alpha,beta,n,'ty2m',ifverbose)
        call avg2(ravg(1,38),tz ,alpha,beta,n,'tz2m',ifverbose)

      endif ! (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 )
c     ############################################################
      timel = time

      if (istep.gt.0 .and. mod(istep,iostep_2d_avg_time).eq.0) then
c     ############################################################
c     spanwise averaging
        do i =1,nstat
          call planar_avg(stat(1,i),ravg(1,i),igs_x) !x averaging
        enddo

        do i =1,nstat
            call x_slice(stat2d(1,1,1,1,i),stat(1,i),w1,w2)
        enddo

        if(nid.eq.0) then
         write(istepc,'(i32)') istep
         istepc=adjustl(istepc)
         icfile=trim('means.'//trim(istepc))
         open(unit=58,file=icfile,form='unformatted')
         do i=1,nstat
          call copy(w3,stat2d(1,1,1,i),m) 
          write(58) w3
         enddo





C         if(restart_means.eq.1 .and. istep.eq.iostep_2d_avg_time) then   !if the last restart file was written during the current session, don't read it and keep on time averaging
C           call input_means(stat_old,time_old) !placeholder, fix this asap. time old should be the total time used for those means
C           t_new=time !assumes time_start=0
C           t_tot=t_new+t_old
C           alpha=t_new/t_tot
C           beta =t_old/t_tot
C           do i =1,nstat
C           call avg1(stat(1,i),stat_old(1,i),alpha,beta,n,'    ',.false.) !time averaging (n? shouldn't it be m?)
C           enddo
C         endif
C         call write_means(stat) !placeholder, fix this asap


c     ############################################################
c     COMPUTE HYDROSTATIC PRESSURE (AVERAGE OF TEMP(y))
c     FOR REFERENCE ON THIS TERM SEE CANTERO 2009 JGR
c
      mn=ny1*nely
      call rzero(tempbar,mn)
      call planar_average_s(tempbar,t(1,1,1,1,1),w1t,w2t)
c
c     ############################################################


      return
      end

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TSTEP'
      include 'PARALLEL'
      include 'NEKUSE'

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      parameter(nel_slab = nelxin*nelyin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)

c     ############################################################


c     ############################################################
c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      ux   = 0.
      uy   = 0.
      uz   = 0.
      temp = 0.

      if (ifield .eq. 1) then               ! velocity
        if(ieg.le.nel_slab.and.iside.eq.5) then
          ux  = vxin_pl(ix,iy,ieg)
          uy  = vyin_pl(ix,iy,ieg)
          uz  = vzin_pl(ix,iy,ieg)
        endif
      elseif (ifield .eq. 2) then     !temperature
        temp = 0.0
        if (ieg.le.nel_slab.and.iside.eq.5) then  
          temp  = tin_pl(ix,iy,ieg)
        endif
      endif
c     ############################################################
c     ############################################################

      return
      end

      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      
      integer n,nelyint,nelytot,mmnely
      real hfh,hfint,amp,delyi,rrleny,rrlenyint,y

      n=8*nelt
c
      nelyint = 30
      nelytot = 44          !<------------ CHANGE! nely in big domain

      delyi =hf/nelyi
      rrleny = nelytot*delyi 
      rrlenyint = nelyint*delyi
      hfh=hf/2.0
      hfint = rrlenyint
      amp = (ASINH((4.0/6.0)*SINH(-3.25)))/(-0.7*3.25)

      do i=1,n
        yc(i,1)  = rrleny * yc(i,1) 
        y=yc(i,1)

        if (y.le.hfh) then
          yc(i,1) = (-1)*(1-SINH(3.25*y)/SINH(3.25))+1
        elseif (y.le.hf) then
          yc(i,1) = (1)*(1 - SINH(3.25*(2-y))/SINH(3.25))+1
        elseif (y.le.hfint) then
          y = y / rrlenyint
          yc(i,1)= (6*SINH(3.25*amp*(0.3-y))/SINH(-3.25))+2
        elseif (y.gt.hfint) then
          y = y/rrleny
          yc(i,1)=y*nelytot-24
        endif
        xc(i,1) =  XLEN * xc(i,1)
c        xc(i,1) =  2.0 * PI * xc(i,1)
        zc(i,1) = ZLEN * zc(i,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
c
      return
      end





      subroutine x_slice (ua,u,w1,w2)
c
c     Extract a y slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nz1,nely,nelz),u (nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nz1,nely,nelz),w2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w2,'+  ',mxz)

      return
      end

c     ##################################################################
      subroutine planar_average_s(ua,u,w1,w2)
c
c     Compute r-t planar average of quantity u()
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelt),w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
c
      ny = ny1*nely
      call rzero(ua,ny)
      call rzero(w1,ny)
c
      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
c
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1
            zz = (1.-zgm1(j,2))/2.  ! = 1 for i=1, = 0 for k=nx1
            aa = zz*area(i,k,1,e) + (1-zz)*area(i,k,3,e)  ! wgtd jacobian
            w1(j,ey) = w1(j,ey) + aa
            ua(j,ey) = ua(j,ey) + aa*u(i,j,k,e)
         enddo
         enddo
         enddo
      enddo
c
      call gop(ua,w2,'+  ',ny)
      call gop(w1,w2,'+  ',ny)
c
      do i=1,ny
         ua(i,1) = ua(i,1) / w1(i,1)   ! Normalize
      enddo

      return
      end

c     ##############################################################

c----------------------------------------------------------------
      subroutine interpolate_inflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow,rlenz
     $          ,dtimestep,restart_inflow)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer step_inflow,nelzin,nel_slab,nelin
      integer restart_inflow
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)



      real zz(nz1,nelz),w1(nz1,nelz),w2(nz1,nelz)
      real zzin(nz1,nelzin)
      integer nzin,flagin,e,m

      real vzinavg,uadum,w1in,z_sup,z_inf
      integer k_sup,k_inf,ez_in,e_pl

      real vxin_pl_dum(lx1,ly1,nel_slab)
     $    ,vyin_pl_dum(lx1,ly1,nel_slab)
     $    ,vzin_pl_dum(lx1,ly1,nel_slab)
     $    ,tin_pl_dum(lx1,ly1,nel_slab)

      real z_inflow_dum

c     ---------------------------------------------------------
      m = nx1*ny1*nel_slab
      call planar_average_z(zz,zm1,w1,w2)
      nzin=nelzin*nz1
      call copy(zzin,zz,nzin)
      if (istep.eq.0.and.restart_inflow.eq.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
         z_inflow = rlenz
         do e=1,nel_slab
          e_pl = nel_slab*(nelzin-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e) = vxin(i,j,nz1,e_pl)
              vyin_pl(i,j,e) = vyin(i,j,nz1,e_pl)
              vzin_pl(i,j,e) = vzin(i,j,nz1,e_pl)
              tin_pl(i,j,e) = tin(i,j,nz1,e_pl)
            enddo
          enddo
         enddo

      elseif (istep.eq.0.and.restart_inflow.eq.1) then
c       This part has to be done by only nid.eq.0
c       (could generate reading issues otherwise)
        z_inflow = 0.0
        z_inflow_dum = 0.0
        call rzero(vxin_pl,m)
        call rzero(vyin_pl,m)
        call rzero(vzin_pl,m)
        call rzero(tin_pl,m)
        call rzero(vxin_pl_dum,m)
        call rzero(vyin_pl_dum,m)
        call rzero(vzin_pl_dum,m)
        call rzero(tin_pl_dum,m)
        if (nid.eq.0) then
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART ####'
          open(unit=58,file='inflow2d.ini',form='binary')
          read(58) z_inflow_dum
          read(58) vxin_pl_dum,vyin_pl_dum,vzin_pl_dum,tin_pl_dum
          close(58)
          write(*,*)'FILE: inflow2d.ini'
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART DONE ###'
        endif
        call gop(z_inflow_dum,z_inflow,'+  ',1)
        call gop(vxin_pl_dum,vxin_pl,'+  ',m)
        call gop(vyin_pl_dum,vyin_pl,'+  ',m)
        call gop(vzin_pl_dum,vzin_pl,'+  ',m)
        call gop(tin_pl_dum,tin_pl,'+  ',m)

      elseif (istep.gt.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
        call planar_average_z_inflow(vzinavg,vzin_pl,nel_slab,w1in)
       
        dz_inflow = dtimestep * vzinavg
        if (z_inflow.lt.dz_inflow) then
          z_inflow = rlenz - (dz_inflow - z_inflow)
        else
          z_inflow = z_inflow - dz_inflow
        endif


        flagin=0
        do e=nelzin,1,-1
          do k=nz1,1,-1
            if (z_inflow.gt.zzin(k,e).and.flagin.eq.0) then
              z_sup = zzin(k+1,e)
              z_inf = zzin(k,e)
              k_sup = k+1
              k_inf = k
              ez_in = e
              flagin=1
            endif
          enddo
        enddo

        do e=1,nel_slab
          e_pl = nel_slab*(ez_in-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e)=((vxin(i,j,k_sup,e_pl)-
     $                       vxin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vxin(i,j,k_inf,e_pl)

              vyin_pl(i,j,e)=((vyin(i,j,k_sup,e_pl)-
     $                       vyin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vyin(i,j,k_inf,e_pl)

              vzin_pl(i,j,e)=((vzin(i,j,k_sup,e_pl)-
     $                       vzin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vzin(i,j,k_inf,e_pl)

              tin_pl(i,j,e) =((tin(i,j,k_sup,e_pl)-
     $                       tin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       tin(i,j,k_inf,e_pl)
            enddo
          enddo
        enddo

      endif

      return
      end


c     ############################################################
      subroutine output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl
     $                           ,nel_slab,z_inflow)
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z_inflow
      integer nel_slab

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)

      character*80 istepc_inflow,icfile_inflow
c    ----------------------------------------------------------

      if (nid.eq.0) then
        write(istepc_inflow,'(i32)') istep
        istepc_inflow=adjustl(istepc_inflow)
        icfile_inflow=trim('inflow2d'//'.'//trim(istepc_inflow))
        open(unit=58,file=icfile_inflow,form='binary')
        write(58) z_inflow
        write(58) vxin_pl,vyin_pl,vzin_pl,tin_pl
        close(58)
      endif

      return
      end

c- constants -----------------------------------------------------------
#define RITAU uparam(1)                         /* Ri_tau */
#define RITAU2 uparam(2)                        /* Ri_tau2 (downstream from the break in slope) */
#define UTARGET uparam(3)                       /* u_target for top PML, positive */ 
#define VISCFAC uparam(4)                       /* viscosity multiplier at ouflow */
#define restart_inflow uparam(5)                /* whether to read inflow2d.ini (2d) for restasting */
#define restart_means abs(uparam(6))/uparam(6)  /* whether to read means.ini for means restasting (>0)*/
#define iostep_2d_avg_time  abs(uparam(6))      /* output frequency for spanwise-time-averaged statistics */
#define iostep_start abs(uparam(7))             /* start interation for means accumulation */
#define iostep_2d_notime uparam(8)              /* output frequency for spanwise-averaged statistics*/
#define iostep_inflow param(15)                 /* frequency of output for inflow2d file */
#define RE_TAU (1/param(2))                     /* Re_tau */

c - mesh and buffer zones dimensions
#define PI (4.*atan(1.))
#define XLEN (8.0*PI/3.0)
#define YLEN uparam(9)
#define ZLEN (uparam(10)*PI)
#define ZBUFF (ZLEN-3.0*PI)
#define YBUFF (YLEN-8.)
#define NUMBER_ELEMENTS_X lelx
#define NUMBER_ELEMENTS_Y lely
#define NUMBER_ELEMENTS_Z lelz
#define ratiozh 3.0       /*fraction of domain before the break*/
#define nhighz 0         /*number of high resolution elements near the break*/

c - Iflow dimensions
#define nelxin 8              /*number of elements of inflow array */
#define nelyin 4
#define nelzin 14
#define zlen_inflow (8.*PI)   /*lenght of inflow domain*/
#define hf 2.0                /*height of inflow domain*/
#define nelyint 13            /*number of elements in the higher resolution zone*/
#define hint 6                /*height of heigher resolution zone*/


      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     TURBULENT OUTFLOW
c     Sets low Re number in range [zout;lenz]
      real zout,zdiff
       
      zout = ZLEN-3*PI                             !<----------CHANGE!
      zdiff=ZLEN-zout
      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)
         if (z.ge.zout)then
               udiff =((param(2)*VISCFAC-param(2))/zdiff)
     $            *(z-zout) + param(2)
         endif
      else if(ifield.eq.2)then                     ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (z.ge.zout) then
          udiff =((param(8)*VISCFAC - param(8))/zdiff)
     $           *(z-zout) + param(8)
        endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz


      real*8 egrav(3)
C     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lz1,lely,lelz)
C 
      integer ex,ey,ez

c     BUFFER ZONE VARIABLES
      real*8 sigma2(3),sigmam1(3),sigmam2(3),beta  !changed sigma to sigma2
     $        ,umean1(3),umean2(3),yy,zz,m,vzout,zz2
      integer if_pml
      save if_pml
      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)

      if (istep.eq.0)then
       if (UTARGET.lt.0.)then
        if_pml=0
       else
        if_pml=1
       endif
      endif

c     MESH VARIABLES 
      egrav(1) = 0.0                         !x: Spanwise direction
      egrav(2) = -1.0*sqrt(1+RITAU**2)       !y: Wall-normal direction
      egrav(3) = 0.0                         !z: Streamwise direction

c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
      call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
      ffx = temp*egrav(1)
      ffy = (temp - tempbar(iy,iz,ey,ez))*egrav(2)
C       ffy = temp*egrav(2)
      ffz = temp*egrav(3)
c     ############################################################
c     ############################################################

c     ############################################################
c     ############################################################
      if (if_pml.eq.1)then
c     Buffer zones
        sigmam1(1) = 0.0                          !<-----------------CHANGE!
        sigmam1(2) = 1.0                          !<-----------------CHANGE!
        sigmam1(3) = 0.0                          !<-----------------CHANGE!

        sigmam2(1) = 0.0                          !<-----------------CHANGE!
        sigmam2(2) = 0.0                          !<-----------------CHANGE!
        sigmam2(3) = 0.0                          !<-----------------CHANGE!

        beta = 2.0                                !<-----------------CHANGE!

        umean1(1) = 0.0                           !<-----------------CHANGE! 
        umean1(2) =-UTARGET                       
        umean1(3) = 0.0                           !<-----------------CHANGE! 
        
        umean2(1) = 0.0                           !<-----------------CHANGE! 
        umean2(2) = 0.0                           !<-----------------CHANGE! 
        umean2(3) = 0.0                           !<-----------------CHANGE! 

        m=(YLEN-YBUFF)/
     &   (ZLEN
     &    -ZBUFF)
        zz = (y-YBUFF)/m 
     & + ZBUFF
        yy = m * (z-ZBUFF)
     & + YBUFF

c     ###############
c     Top buffer zone
        sigma2(1) = 0.0
        sigma2(2) = 0.0
        sigma2(3) = 0.0
        if (y.ge.YBUFF.and.z.le.zz) then
          sigma2(1) = sigmam1(1)*((y - YBUFF)/
     &      (YLEN-YBUFF))**(beta)
          sigma2(2) = sigmam1(2)*((y - YBUFF)/
     &       (YLEN-YBUFF))**(beta)
          sigma2(3) = sigmam1(3)*((y - YBUFF)/
     &       (YLEN-YBUFF))**(beta)

          ffx = ffx - sigma2(1) * (ux - umean1(1))
          ffy = ffy - sigma2(2) * (uy - umean1(2)) 
          ffz = ffz - sigma2(3) * (uz - umean1(3))
        endif
      endif !if_pml.eq.1
c     ###################
c     Outflow buffer zone
      if(.true.) then
          sigma2(1) = 0.0
          sigma2(2) = 0.0
          sigma2(3) = 0.0

          sigmam2(1) = 0.0                          !<-----------------CHANGE!
          sigmam2(2) = 0.0                          !<-----------------CHANGE!
          sigmam2(3) = 1.0                          !<-----------------CHANGE!

          umean2(1) = 0.0                           !<-----------------CHANGE! 
          umean2(2) = 0.0                           !<-----------------CHANGE! 
          umean2(3) = 0.0                           !<-----------------CHANGE!

          beta = 2.0

          zz2=(z-ZBUFF)/
     &      (ZLEN
     &      -ZBUFF)
          m=(YLEN-YBUFF)/
     &   (ZLEN
     &    -ZBUFF)
          yy = m * (z-ZBUFF)
     & + YBUFF

          call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          vzout = vzout_pl(ix,iy,ex,ey)

          if (z.ge.ZBUFF
     &      .and.y.lt.yy.and.vzout.lt.0.0) then
            sigma2(1) = sigmam2(1)*(zz2)**(beta)
            sigma2(2) = sigmam2(2)*(zz2)**(beta)
            sigma2(3) = sigmam2(3)*(zz2)**(beta)

            ffx = ffx - sigma2(1) * (ux - umean2(1))
            ffy = ffy - sigma2(2) * (uy - umean2(2))
            ffz = ffz - sigma2(3) * (uz - umean2(3))
          endif
      endif
c     ################# 


      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)
 
      qvol   = 0.0
      source = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

c     ############################################################
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
      integer nelin,nel_slab,nin
      real rlenz,z_inflow,dz_inflow
      real dtimestep
      integer set_IC_flag

c     If set_IC_flag.eq.1 copy inflow file at bottom of big domain
      parameter(set_IC_flag=0)                           !<----- CHANGE!

      parameter(nelin=nelxin*nelyin*nelzin)
      parameter(nel_slab=nelxin*nelyin)
      parameter(nin = nelin*lx1*ly1*lz1)

      integer if_mean_2d
      save if_mean_2d

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)
      save z_inflow
      real theta

c     spanwise-averaged arrays
      real    yavgx(ny1,nz1,lely,lelz)
     $    ,   zavgx(ny1,nz1,lely,lelz)

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)
     & , su3m_2d_o(lx1,ly1,lz1,lelt,4)
     & , sv2u_2d_o(lx1,ly1,lz1,lelt,6)
     & , spmm_2d_o(lx1,ly1,lz1,lelt,4)
     & , timem,atimem,timelm,dtimem,t_tot

      integer counter1

      logical ifverbose
      real   wo1(lx1,ly1,lz1,lelv)
     &      ,  wo2(lx1,ly1,lz1,lelv)
     

      real             w1(ly1,lz1,lely,lelz)
     &              ,  w2(ly1,lz1,lely,lelz)
     &              ,  w3(ly1,lz1,lely,lelz)
     &              ,  w4(ly1,lz1,lely,lelz)
     &              ,  wy1(ly1,nely)
     &              ,  wy2(ly1,nely)
      save igs_x, igs_z

c     2d spanwise-averaged arrays 
      real v2d(ly1,lz1,lely,lelz),w2d(ly1,lz1,lely,lelz),
     &     y2d(ly1,lz1,lely,lelz),z2d(ly1,lz1,lely,lelz),
     &     tt2d(ly1,lz1,lely,lelz)


c     depth-averaged arrays
      real zavgxy(nz1,lelz)

c     dWh/dz (from cons. of mass dUh/dz=we)
      real    dzwavgxy(nz1,lelz),
     $        dzwavgxy_fltr(nz1,lelz)
c
c     Interface position array (intr) and threshold delta
      real intr(nz1,lelz)

c     average in time variables
      integer icalled
      save    icalled
      data    icalled /0/

      real atime,timel
      save atime,timel
      real alpha,beta
      integer n,nt

      integer icnt_time
      save    icnt_time
      data    icnt_time /0/

      integer icnt
      save    icnt
      data    icnt /0/
c
      character*32 istepc,outfile

      character*80 icfile
c
c     Gradient arrays for shear velocity, 
c     tke production and dissipation computation
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vyx(lx1,ly1,lz1,lelv),
     $     vyy(lx1,ly1,lz1,lelv),
     $     vyz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv),
     $     tx(lx1,ly1,lz1,lelv),
     $     ty(lx1,ly1,lz1,lelv),
     $     tz(lx1,ly1,lz1,lelv)

c     ############################################################
C       parameter(INTP_NMAX=ly1*lz1*lely*lelz)
      parameter(mz=lz1*lelz*3)
      parameter(myint=ly1*lely*3)
      parameter(INTP_NMAX=mz*myint)

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h, intp_h2
      save    nint, intp_h, intp_h2

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      real wintr(INTP_NMAX)
      save wintr
      real ymm(ly1,lz1,lely,lelz)
      save ymm
      real deltaz ,zdum
      save deltaz,zdum
      real  wintr3(myint), wintr2(myint)
      save wintr3,wintr2
      real y_inter(myint), tline(myint)
      save y_inter,tline
c     ############################################################
c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lz1,lely,lelz)
      
       common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)
       real vzout_pldum(lx1,ly1,lelx,lely)

      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      parameter (n_slab=ly1*nelyin)
      real wslab(n_slab)
      common /inflow_interp/ y_slab(n_slab)

      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z
      n=nx1*ny1*nz1*nelv  
      nt=nx1*ny1*nz1*nelt
      m=ny1*nz1*nely*nelz
c     Restore geometry after loading the IC 
      if (istep.eq.0) then
       call opcopy(xm1,ym1,zm1,xmo,ymo,zmo)  ! Restore my geometry
       call geom_reset(1)                    ! Force regen. of Jacobians 
      endif

cc     ############################################################

c     ############################################################
c
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
c
c     This code is made for a mesh composed of only one box.
c     Computes the inlet boundary condition for the next time step
c     interpolating the solution for a TC with fixed mean 
c     streamwise velocity and concentration
      if (istep.eq.0) then
            call yslab(y_slab,ym1,wslab,n_slab,nelyin)
      endif

      dtimestep = abs(dt)
      theta=atan(1/RITAU)
c     READ INFLOW
      if (istep.eq.0) then
        call read_inflow(vxin,vyin,vzin,tin,nelin,nin)
        if (set_IC_flag.eq.1) then
          call set_IC(vxin,vyin,vzin,tin,nelin,nelxin,nelyin,nelzin
     $               ,nel_slab,theta)
        endif
      endif

      call interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow
     $          ,zlen_inflow,dtimestep,int(restart_inflow))
      if (mod(istep,int(iostep_inflow)).eq.0) then
        call output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl,nel_slab
     $                       ,z_inflow)
      endif

c     ############################################################
c     OUTPUT INITIAL CONDITION
      if (istep.eq.0) then
        ifxyo = .true.
        call prepost(.true.,'   ' )
        ifxyo = .false.
        call print_yz_mesh
      endif

c     ############################################################
      if (istep.eq.0) then 
        call x_slice(ymm,ym1,w1,w2)
      endif
      if(icalled.eq.0) then
        call rzero(rumm,size(rumm))
        call rzero(ru2m,size(ru2m))
        call rzero(ruvm,size(ruvm))
        call rzero(ruxm,size(ruxm))
        call rzero(rux2,size(rux2))
        call rzero(ru3m,size(rux2))
        call rzero(rv2u,size(rux2))
        call rzero(rpmm,size(rux2))
        call gtpp_gs_setup(igs_x,nelx,nely,  nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1,nelz,3) ! z-avx
        call interp_setup(intp_h,0.0,0,nelt)
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,1.0,size(xint))
        endif
        do i=1,INTP_NMAX
            j=i-int((i-1)/myint)*myint
            yint(i)=(j-1.)*1./(myint-1)
            yint(i)=tanh(2.5*(yint(i)-1.))/tanh(2.5)+1.
            yint(i)=yint(i)*YLEN
            if (i.le.myint) y_inter(i)=yint(i)
            j=int((i-1)/myint)+1
            zint(i)=(j-1.)*(ZLEN)/(mz-1)
        enddo
        deltaz=zint(myint+1)-zint(1)
        iffpts = .true. ! dummy call to find points
         call interp_nfld(wintr,wo1,1,xint,yint,zint,nint,
     $                   iwk,rwk,INTP_NMAX,iffpts,intp_h)
        iffpts = .false.
        atime = 0.
        timel = time
        icalled = 1
      endif !(icalled.eq.0)
      dtime = time - timel
      atime = atime + dtime
c     ############################################################

c     write 2d spanwise-averaged files 
      if(mod(istep,int(iostep_2d_notime)).eq.0) then
          call planar_avg(wo1,vz,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(w2d)

          call planar_avg(wo1,vy,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(v2d)

          call planar_avg(wo1,t(1,1,1,1,1),igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(tt2d)
          call nekgsync()

          call output_2d(time,w2d,v2d,tt2d)
      endif


c     ############################################################
c     COMPUTE HYDROSTATIC PRESSURE (AVERAGE OF TEMP(y))
c     FOR REFERENCE ON THIS TERM SEE CANTERO 2009 JGR
      call rzero(tempbar,m) !wo1,2(lx1,ly1,lz1,lelv)
      call cfill(wintr,151413121110987654321.,size(wintr))
      call rzero(tline,myint)
      call planar_avg(wo1,t(1,1,1,1,1),igs_x)  !wo1,2(lx1,ly1,lz1,lelv)

      call interp_nfld(wintr,wo1,1,xint,yint,zint,INTP_NMAX,
     $                       iwk,rwk,INTP_NMAX,iffpts,intp_h)
      if(nid.eq.0) then
        do i=1,myint
          zdum=0.0
          do j=1,mz
              k=i+(j-1)*myint
              if (wintr(k).ne.151413121110987654321.) then
                tline(i)=tline(i)+wintr(k)*deltaz
                zdum=zdum+deltaz
              endif
            enddo
          tline(i)=tline(i)/zdum
        enddo
        call spline(y_inter,tline,myint,wintr2,wintr3)
        do i=1,m
          call splint(y_inter,tline,wintr2,myint,ymm(i,1,1,1),
     $         tempbar(i,1,1,1))
        enddo
      endif
      call rzero(w1,m)
      call gop(tempbar,w1,'+  ',m)

c      ############################################################
c     SAVE OUTFLOW PLANE

      call vz_outflow(vzout_pl,vzout_pldum)

c     ############################################################

      if (istep.lt.int(iostep_start) 
     &  .and.restart_means.gt.0)  return

c     averaging over time
      if (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 ) then
        beta      = dtime / atime
        if (uparam(7).lt.0) beta = 1.0   !means will not be accumulated on time. Not the most elegant solution, I know.
        alpha     = 1. - beta
c     compute gradients
        call gradm1(vxx,vxy,vxz,vx)
        call gradm1(vyx,vyy,vyz,vy)
        call gradm1(vzx,vzy,vzz,vz)
        call gradm1(tx,ty,tz,t(1,1,1,1,1))

        ifverbose = .false.
c       Compute time-average of u,v,w and t       
        call avg1(rumm(1,1,1,1,1),vx,alpha,beta,n,'uavg',ifverbose)
        call avg1(rumm(1,1,1,1,2),vy,alpha,beta,n,'vavg',ifverbose) 
        call avg1(rumm(1,1,1,1,3),vz,alpha,beta,n,'wavg',ifverbose) 
        call avg1(rumm(1,1,1,1,4),t, alpha,beta,n,'tavg',ifverbose)
c       Compute time-average of u^2,v^2,w^2 and t^2     
        call avg2(ru2m(1,1,1,1,1),vx,alpha,beta,n,'u2mm',ifverbose)
        call avg2(ru2m(1,1,1,1,2),vy,alpha,beta,n,'v2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,3),vz,alpha,beta,n,'w2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,4),t ,alpha,beta,n,'t2mm',ifverbose)

c       Compute time-average of cross products
        call avg3(ruvm(1,1,1,1,1),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg3(ruvm(1,1,1,1,2),vx,vz,alpha,beta,n,'uwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,3),vx, t,alpha,beta,n,'utmm',ifverbose)
        call avg3(ruvm(1,1,1,1,4),vy,vz,alpha,beta,n,'vwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,5),vy, t,alpha,beta,n,'vtmm',ifverbose)
        call avg3(ruvm(1,1,1,1,6),vz, t,alpha,beta,n,'wtmm',ifverbose)
c       Compute time-average of gradients     
        call avg1(ruxm(1,1,1,1,1),vxx,alpha,beta,n,'uxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,2),vxy,alpha,beta,n,'uymm',ifverbose)
        call avg1(ruxm(1,1,1,1,3),vxz,alpha,beta,n,'uzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,4),vyx,alpha,beta,n,'vxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,5),vyy,alpha,beta,n,'vymm',ifverbose)
        call avg1(ruxm(1,1,1,1,6),vyz,alpha,beta,n,'vzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,7),vzx,alpha,beta,n,'wxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,8),vzy,alpha,beta,n,'wymm',ifverbose)
        call avg1(ruxm(1,1,1,1,9),vzz,alpha,beta,n,'wzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,10),tx ,alpha,beta,n,'txmm',ifverbose)
        call avg1(ruxm(1,1,1,1,11),ty ,alpha,beta,n,'tymm',ifverbose)
        call avg1(ruxm(1,1,1,1,12),tz ,alpha,beta,n,'tzmm',ifverbose)
c       Compute time-average of squared gradients
        call avg2(rux2(1,1,1,1,1),vxx,alpha,beta,n,'ux2m',ifverbose)
        call avg2(rux2(1,1,1,1,2),vxy,alpha,beta,n,'uy2m',ifverbose)
        call avg2(rux2(1,1,1,1,3),vxz,alpha,beta,n,'uz2m',ifverbose)

        call avg2(rux2(1,1,1,1,4),vyx,alpha,beta,n,'vx2m',ifverbose)
        call avg2(rux2(1,1,1,1,5),vyy,alpha,beta,n,'vy2m',ifverbose)
        call avg2(rux2(1,1,1,1,6),vyz,alpha,beta,n,'vz2m',ifverbose)

        call avg2(rux2(1,1,1,1,7),vzx,alpha,beta,n,'wx2m',ifverbose)
        call avg2(rux2(1,1,1,1,8),vzy,alpha,beta,n,'wy2m',ifverbose)
        call avg2(rux2(1,1,1,1,9),vzz,alpha,beta,n,'wz2m',ifverbose)

        call avg2(rux2(1,1,1,1,10),tx ,alpha,beta,n,'tx2m',ifverbose)
        call avg2(rux2(1,1,1,1,11),ty ,alpha,beta,n,'ty2m',ifverbose)
        call avg2(rux2(1,1,1,1,12),tz ,alpha,beta,n,'tz2m',ifverbose)
c        Compute time average of u^3, v^3, w^3, t^3
        call avg3(ru3m(1,1,1,1,1),ru2m(1,1,1,1,1),vx, alpha,beta,n,
     &                                            'u3mm',ifverbose)
        call avg3(ru3m(1,1,1,1,2),ru2m(1,1,1,1,2),vy, alpha,beta,n,
     &                                            'v3mm',ifverbose)
        call avg3(ru3m(1,1,1,1,3),ru2m(1,1,1,1,3),vz, alpha,beta,n,
     &                                            'w3mm',ifverbose)
        call avg3(ru3m(1,1,1,1,4),ru2m(1,1,1,1,4),t, alpha,beta,n,
     &                                            't3mm',ifverbose)
c        Compute uv^2,uw^2, etc
        call avg3(rv2u(1,1,1,1,1),ru2m(1,1,1,1,1),vy, alpha,beta,n,
     &                                            'vu2m',ifverbose)
        call avg3(rv2u(1,1,1,1,2),ru2m(1,1,1,1,1),vz, alpha,beta,n,
     &                                            'wu2m',ifverbose)
        call avg3(rv2u(1,1,1,1,3),ru2m(1,1,1,1,2),vx, alpha,beta,n,
     &                                            'uv2m',ifverbose)
        call avg3(rv2u(1,1,1,1,4),ru2m(1,1,1,1,2),vz, alpha,beta,n,
     &                                            'wv2m',ifverbose)
        call avg3(rv2u(1,1,1,1,5),ru2m(1,1,1,1,3),vx, alpha,beta,n,
     &                                            'uw2m',ifverbose)
        call avg3(rv2u(1,1,1,1,6),ru2m(1,1,1,1,3),vy, alpha,beta,n,
     &                                            'vw2m',ifverbose)
c        Compute p, up, vp, wp
        call avg1(rpmm(1,1,1,1,1),pr,alpha,beta,n,'pavg',ifverbose)
        call avg3(rpmm(1,1,1,1,2),pr,vx, alpha,beta,n,'upmm',ifverbose)
        call avg3(rpmm(1,1,1,1,3),pr,vy, alpha,beta,n,'vpmm',ifverbose)
        call avg3(rpmm(1,1,1,1,4),pr,vz, alpha,beta,n,'wpmm',ifverbose)
      endif ! (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 )
      timel = time 

c     ############################################################

      if (istep.ne.0 .and. 
     &    mod(istep,int(iostep_2d_avg_time)).eq.0) then
c     spanwise averaging
        do i =1,12
          call planar_avg(suxm(1,1,1,1,i),ruxm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(suxm(1,1,1,1,i),w1)     !x_slice2 and 3 take an slice on the yz plane. They are both needed to avoid unnnecessary memory declarations on all procceses
          if (nid.eq.0) call x_slice3(suxm_2d(1,1,1,1,i))
          call planar_avg(sux2(1,1,1,1,i),rux2(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(sux2(1,1,1,1,i),w1)
          if (nid.eq.0) call x_slice3(sux2_2d(1,1,1,1,i))
        enddo
        do i =1,6
          call planar_avg(suvm(1,1,1,1,i),ruvm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(suvm(1,1,1,1,i),w1)
          if (nid.eq.0)  call x_slice3(suvm_2d(1,1,1,1,i))
          call planar_avg(sv2u(1,1,1,1,i),rv2u(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(sv2u(1,1,1,1,i),w1)
          if (nid.eq.0)   call x_slice3(sv2u_2d(1,1,1,1,i))
        enddo
        do i =1,4
          call planar_avg(summ(1,1,1,1,i),rumm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(summ(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(summ_2d(1,1,1,1,i))
          call planar_avg(su2m(1,1,1,1,i),ru2m(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(su2m(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(su2m_2d(1,1,1,1,i))
          call planar_avg(su3m(1,1,1,1,i),ru3m(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(su3m(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(su3m_2d(1,1,1,1,i))
          call planar_avg(spmm(1,1,1,1,i),rpmm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(spmm(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(spmm_2d(1,1,1,1,i))
        enddo
        call nekgsync()
         if (restart_means.gt.0) then
          call output_means(atime,timel,dtime,w4)
         endif
      endif !(istep.gt.0 .and. mod(istep,int(iostep_2d_avg_time)).eq.0)
c     ############################################################
c     load restart statistics and average them with the new ones 
      if(restart_means.lt.0 .and.nid.eq.0 .and.
     &  mod(istep,int(iostep_2d_avg_time)).eq.0 .and. istep.ne.0) then
        if (istep.eq.int(iostep_2d_avg_time)) then !this variables remain in a common block, it's not necessary to load them everytime
          call input_means()
        endif
        t_tot=atime+atimem
        alpha=atime/t_tot
        beta=1-alpha
        ifverbose= .false.
        do i=1,4
          call avg1(summ_2d(1,1,1,1,i),summ_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'uavg',ifverbose)
        enddo
        do i=1,4
          call avg1(su2m_2d(1,1,1,1,i),su2m_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'u2mm',ifverbose)
        enddo
        do i=1,6
           call avg1(suvm_2d(1,1,1,1,i),suvm_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'uvmm',ifverbose)
        enddo
        do i=1,12
           call avg1(suxm_2d(1,1,1,1,i),suxm_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'uxmm',ifverbose)
        enddo
        do i=1,12
           call avg1(sux2_2d(1,1,1,1,i),sux2_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'ux2m',ifverbose)
        enddo
        do i=1,4
           call avg1(su3m_2d(1,1,1,1,i),su3m_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'u3mm',ifverbose)
        enddo
        do i=1,6
           call avg1(sv2u_2d(1,1,1,1,i),sv2u_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'v2um',ifverbose)
        enddo
        do i=1,4
           call avg1(spmm_2d(1,1,1,1,i),spmm_2d_o(1,1,1,1,i),alpha,beta,
     &        m,'pavg',ifverbose)
        enddo
        call output_means(t_tot,timel,dtime,w4)
      endif !(restart_means.lt.0 .and. istep.eq.iostep_2d_avg_time)

      return
      end

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NEKNEK'

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      parameter(nel_slab = nelxin*nelyin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)

      real ewfac
      integer if_pml
      save if_pml
      integer e
      real theta1,chr,shr

      e = gllel(ieg)

      if (istep.eq.0)then
       if (UTARGET.lt.0.)then
        if_pml=0
       else
        if_pml=1
       endif
      endif

      ux   = 0.
      uy   = 0.
      uz   = 0.
      temp = 0.
c     ############################################################
c     STABILIZED OUTFLOW Dong et all JCP
      if (cbu.eq.'o  ') then
         U0 = 1.0                  ! characteristic velocity
         delta = 0.1               ! small positive constant
         pa = dongOutflow(ix,iy,iz,e,iside,U0,delta)
      endif
c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE

      theta1=atan(1.0/RITAU)
      chr=cos(theta1)
      shr=sin(theta1)

      if (if_pml.eq.1) then
        if (ifield .eq. 1) then               ! velocity
          if(ieg.le.nel_slab.and.iside.eq.5) then
            ux  = vxin_pl(ix,iy,ieg)
            uy  = vyin_pl(ix,iy,ieg)*chr-vzin_pl(ix,iy,ieg)*shr
            uz  = vzin_pl(ix,iy,ieg)*chr+vyin_pl(ix,iy,ieg)*shr
          endif
        elseif (ifield .eq. 2) then     !temperature
          temp = 0.0
          if (ieg.le.nel_slab.and.iside.eq.5) then  
            temp  = tin_pl(ix,iy,ieg)
          endif
        endif
      else
        ewfac = -1.0*UTARGET          
        zstart = 0                    !<----------------------CHANGE
        zstart1 = zstart + 1.         !<----------------------CHANGE
        zend = ZLEN
        zend1 = zend - 1.             !<----------------------CHANGE

        if (ifield .eq. 1) then               ! velocity
          if (iside.eq.3) then
              ux = 0.0
c           This coflow is only for the top wall of the domain
              if (z.ge.zstart.and.z.le.zstart1) then
                uy= ((z-zstart-1.)**8 - 1.)*ewfac
              elseif (z.ge.zstart1.and.z.le.zend1) then
                uy= (-1)*ewfac
              elseif (z.ge.zend1.and.z.le.zend) then
                uy= ((z-zend+1.)**8 - 1.)*ewfac
              endif
              uz = 0.0

          elseif(ieg.le.nel_slab.and.iside.eq.5) then
            ux  = vxin_pl(ix,iy,ieg)
            uy  = vyin_pl(ix,iy,ieg)*chr-vzin_pl(ix,iy,ieg)*shr
            uz  = vzin_pl(ix,iy,ieg)*chr+vyin_pl(ix,iy,ieg)*shr
          endif

        elseif (ifield .eq. 2) then     !temperature
          temp = 0.0
          if (ieg.le.nel_slab.and.iside.eq.5) then
            temp  = tin_pl(ix,iy,ieg)
          endif
        endif
      endif
c     ############################################################
c     #########################################################

      return
      end

      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0



      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      
      integer n,nelytot,mmnely
      real hfh,hfint,amp,delyi,rrleny,rrlenyint,y,z
      real theta1, theta2, A1, A2, zh1, zh2, anint
      real deltz1, deltz0
      integer nz_break

      theta1=atan(1/RITAU)
      theta2=atan(1/RITAU2)
      nz_break=aint(NUMBER_ELEMENTS_Z/ratiozh)
      zh1=aint(NUMBER_ELEMENTS_Z/ratiozh)*ZLEN/NUMBER_ELEMENTS_Z
      zh2=ZLEN-zh1
      A1=zh1/RITAU   !zh*tan(theta)
      A2=zh2/RITAU2
C       A1=0
C       A2=0
      n=8*nelt
c
      nelytot = NUMBER_ELEMENTS_Y

      delyi =hf/nelyin
      rrleny = nelytot*delyi 
      rrlenyint = nelyint*delyi
      hfh=hf/2.0
      hfint = rrlenyint
      amp=ASINH(((hint-hf)/hint)*SINH(-3.25))/((hf/rrlenyint-1.0)*3.25)

c     vertical grid spacing      
      do i=1,n
        yc(i,1)  = rrleny * yc(i,1) 
        y=yc(i,1)

        if ((AINT(y*100.0)/100.0).le.hfh) then
          yc(i,1) = (-1)*(1-SINH(3.25*y)/SINH(3.25))+1
        elseif ((AINT(y*100.0)/100.0).le.hf) then
          yc(i,1) = (1)*(1 - SINH(3.25*(2-y))/SINH(3.25))+1
        elseif ((AINT(y*100.0)/100.0).le.hfint) then
          y = y / rrlenyint
          yc(i,1)= (hint*SINH(3.25*amp*(hf/rrlenyint-y))/SINH(-3.25))+2
        elseif ((AINT(y*100.0)/100.0).gt.hfint) then
              yc(i,1)=(y-hfint)*(YLEN-hint)/(rrleny-hfint)+hint
C             y=(y-hfint)/(rrleny-hfint)
C             yc(i,1)=y*(YLEN-hfint)+hfint
        endif
        xc(i,1) =  XLEN * xc(i,1)
        zc(i,1) = ZLEN * zc(i,1)
      enddo

      if (nhighz.ne.0) then
        deltz1=ZLEN/(1.0*NUMBER_ELEMENTS_Z-1.0*nhighz/2.0)
        deltz0=ZLEN/NUMBER_ELEMENTS_Z
        do i=1,n
          z=zc(i,1)
          if ((AINT(z*100.0)/100.0).le.(deltz0*(nz_break-nhighz/2)))then
            zc(i,1)=z*(zh1-nhighz/4*deltz1)/((nz_break-nhighz/2)*deltz0)
          elseif((AINT(z*100.0)/100.0).le.(deltz0*(nz_break+nhighz/2)))
     &          then
            zc(i,1)=0.5*(deltz1/deltz0)*(z-(nz_break-nhighz/2)
     &              *deltz0)+zh1-nhighz*deltz1/4
          else
            zc(i,1)=(ZLEN-zh1+nhighz*deltz0/4)/
     &              (ZLEN-(nhighz*deltz1/2))*
     &              (z-(nz_break+nhighz/2)*deltz0)
     &              +zh1+nhighz*deltz1/4
          endif
        enddo
      endif

c     sloping
      do i=1,n
        y=yc(i,1)
        z=zc(i,1)
        if((AINT(z*100.0)/100.0).lt.zh1) then
          if((AINT(y*100.0)/100.0).le.hint) then
            yc(i,1)=y+A1*((-1.0/zh1)*z+1)+A2
          else
            yc(i,1)=y+((-A1/(YLEN-hint))*(y-hint)+A1)*
     &                ((-1.0/zh1)*z+1)+
     &                ((-A2/(YLEN-hint))*(y-hint)+A2)
          endif !(y.le.hfint)
        else
          if((AINT(y*100.0)/100.0).le.hint) then
            yc(i,1)=y+A2*((-1.0/zh2)*(z-zh1)+1)
          else
            yc(i,1)=y+((-A2/(YLEN-hint))*
     &         (y-hint)+A2)*((-1.0/zh2)*
     &                (z-zh1)+1)
          endif !(y.le.hfint)
        endif !(z.lt.zh)
      enddo

      return
      end
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      if (UTARGET.lt.0.)then  !change top BC from O to v
          ifc=3 !top face, if it was generated by genbox
          do iel=1,nelt
          if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'v  '
          enddo
      endif

      call opcopy(xmo,ymo,zmo,xm1,ym1,zm1)  ! Preserve my geometry
c
      return
      end
      
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end

c-----------------------------------------------------------------------
      subroutine planar_inflow(ua,u,mnelin,w1)
c
c     Compute r-s planar average of quantity u()
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      integer e,eg,mnelin,nxyin
      real u(nx1*ny1,mnelin),aindum(nx1*ny1,mnelin)
      real ain(nx1*ny1,mnelin),ua,uadum,w1,w1dum
c
c     As the numbering of elements in a single box
c     go in the order of r-s-t (first fill r, then 
c     s and then t) the ordering of the 2d elements 
c     in u (2d inlet) is the same as the first 
c     t-plane of elements in the 3d box. Hence,
c     face 5 of the first mnelin elements of the 
c     3dbox have the same area as the 2d inlet.

      nxyin = nx1*ny1*mnelin
      call rzero(ain,nxyin)
      call rzero(aindum,nxyin)
      do e=1,nelt
c        l local gl global el element
         eg = lglel(e)
         if (eg.le.mnelin) then
           do i=1,nx1*ny1
              aindum(i,eg) = area(i,1,5,e)
           enddo
         endif
      enddo
      call gop(aindum,ain,'+  ',nxyin)

      ua=0.0
      uadum=0.0
      w1=0.0
      w1dum=0.0

      if (nid.eq.0) then
       do e=1,mnelin
          do i=1,nx1*ny1
            w1dum = w1dum + ain(i,e)
            uadum = uadum + ain(i,e)*u(i,e)
          enddo
       enddo
       uadum = uadum / w1dum ! Normalize
      endif
      call gop(ua,uadum,'+  ',1)      
      call gop(w1,w1dum,'+  ',1)      


      return
      end

c----------------------------------------------------------------
      subroutine interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin1,z_inflow,rlenz
     $          ,dtimestep,restart_inflow1)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer step_inflow,nelzin1,nel_slab,nelin
      integer restart_inflow1
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)



      real zz(nz1,nelz),w1(nz1,nelz),w2(nz1,nelz)
      real zzin(nz1,nelzin1)
      integer nzin,flagin,e,m

      real vzinavg,uadum,w1in,z_sup,z_inf
      integer k_sup,k_inf,ez_in,e_pl

      real vxin_pl_dum(lx1,ly1,nel_slab)
     $    ,vyin_pl_dum(lx1,ly1,nel_slab)
     $    ,vzin_pl_dum(lx1,ly1,nel_slab)
     $    ,tin_pl_dum(lx1,ly1,nel_slab)

      real z_inflow_dum

c     ---------------------------------------------------------
      m = nx1*ny1*nel_slab
      call planar_average_z(zz,zm1,w1,w2)
      nzin=nelzin1*nz1
      call copy(zzin,zz,nzin)
      if (istep.eq.0.and.restart_inflow1.eq.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
         z_inflow = rlenz
         do e=1,nel_slab
          e_pl = nel_slab*(nelzin1-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e) = vxin(i,j,nz1,e_pl)
              vyin_pl(i,j,e) = vyin(i,j,nz1,e_pl)
              vzin_pl(i,j,e) = vzin(i,j,nz1,e_pl)
              tin_pl(i,j,e) = tin(i,j,nz1,e_pl)
            enddo
          enddo
         enddo

      elseif (istep.eq.0.and.restart_inflow1.eq.1) then
c       This part has to be done by only nid.eq.0
c       (could generate reading issues otherwise)
        z_inflow = 0.0
        z_inflow_dum = 0.0
        call rzero(vxin_pl,m)
        call rzero(vyin_pl,m)
        call rzero(vzin_pl,m)
        call rzero(tin_pl,m)
        call rzero(vxin_pl_dum,m)
        call rzero(vyin_pl_dum,m)
        call rzero(vzin_pl_dum,m)
        call rzero(tin_pl_dum,m)
        if (nid.eq.0) then
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART ####'
          open(unit=58,file='inflow2d.ini',access='stream',
     &       form='unformatted')
          read(58) z_inflow_dum
          read(58) vxin_pl_dum,vyin_pl_dum,vzin_pl_dum,tin_pl_dum
          close(58)
          write(*,*)'FILE: inflow2d.ini'
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART DONE ###'
        endif
        call gop(z_inflow_dum,z_inflow,'+  ',1)
        call gop(vxin_pl_dum,vxin_pl,'+  ',m)
        call gop(vyin_pl_dum,vyin_pl,'+  ',m)
        call gop(vzin_pl_dum,vzin_pl,'+  ',m)
        call gop(tin_pl_dum,tin_pl,'+  ',m)

      elseif (istep.gt.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
        call planar_inflow(vzinavg,vzin_pl,nel_slab,w1in)
       
        dz_inflow = dtimestep * vzinavg
        if (z_inflow.lt.dz_inflow) then
          z_inflow = rlenz - (dz_inflow - z_inflow)
        else
          z_inflow = z_inflow - dz_inflow
        endif


        flagin=0
        do e=nelzin1,1,-1
          do k=nz1,1,-1
            if (z_inflow.gt.zzin(k,e).and.flagin.eq.0) then
              z_sup = zzin(k+1,e)
              z_inf = zzin(k,e)
              k_sup = k+1
              k_inf = k
              ez_in = e
              flagin=1
            endif
          enddo
        enddo

        do e=1,nel_slab
          e_pl = nel_slab*(ez_in-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e)=((vxin(i,j,k_sup,e_pl)-
     $                       vxin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vxin(i,j,k_inf,e_pl)

              vyin_pl(i,j,e)=((vyin(i,j,k_sup,e_pl)-
     $                       vyin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vyin(i,j,k_inf,e_pl)

              vzin_pl(i,j,e)=((vzin(i,j,k_sup,e_pl)-
     $                       vzin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vzin(i,j,k_inf,e_pl)

              tin_pl(i,j,e) =((tin(i,j,k_sup,e_pl)-
     $                       tin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       tin(i,j,k_inf,e_pl)
            enddo
          enddo
        enddo

      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine x_slice (ua,u,w1,w2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nz1,nely,nelz),u(nx1,ny1,nz1,nelt),
     $     w1(ny1,nz1,nely,nelz),w2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w2,'+  ',myz)

      return
      end

      subroutine x_slice2 (u,w1)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c     It doesn't return the result. 
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real u(nx1,ny1,nz1,nelt),
     $     w1(ny1,nz1,nely,nelz)
      integer nst,ist
      integer e,eg,ex,ey,ez
      real dy2
C       real ua(ny1,nz1,nely,nelz)
      common /xslice2/
     &   ua(ly1,lz1,lely,lelz)
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',myz)

      return
      end

      subroutine x_slice3 (ua2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c     It must be called RIGHT AFTER x_slice2
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
      common /xslice2/
     &   ua(ly1,lz1,lely,lelz)

c
      myz = nely*nelz*ny1*nz1
      call rzero(ua2,myz)

      call copy(ua2,ua,myz)
      return
      end
c---------------------------------------------------------------------      
      subroutine y_line (ua,u,w1,w2)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
      real dy2
c
      my = nely*ny1
      call rzero(ua,my)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1) then
            do j=1,ny1
               ua(j,ey) = u(i,j,k,e)
            enddo
         endif
      enddo
      call gop(ua,w2,'+  ',my)

      return
      end
c--------------------------------------------------------------------- 
      subroutine yslab (ua,u,w1,nslab,nely_in)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nslab),u(nx1,ny1,nz1,nelv)
     $    ,w1(nslab)
      integer e,eg,ex,ey,ez
      real dy2
c
C       my = nely*ny1
      call rzero(ua,nslab)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1.and. ey.le.nely_in) then
            do j=1,ny1
               ua(j+ey*ny1-ny1) = u(i,j,k,e)-u(1,1,1,1)
            enddo
         endif
      enddo
      call gop(ua,w1,'+  ',nslab)

      return
      end     
C       subroutine z_line (ua,u,w1,w2)
C c
C c     Extract a z line of quantity u() - assumes global tens.prod.
C c
C       include 'SIZE'
C       include 'GEOM'
C       include 'PARALLEL'
C       include 'WZ'
C       include 'ZPER'
C c
C       real ua(nz1,nelz),u(nx1,ny1,nz1,nelv)
C       real w1(nz1,nelz),w2(nz1,nelz)
C       integer e,eg,ex,ey,ez
C       real dy2
C c
C       mz = nelz*nz1
C       call rzero(ua,mz)
C       call rzero(w1,mz)
C       call rzero(w2,mz)
C c
C       do e=1,nelt
C c
C          eg = lglel(e)
C          call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
C          i = 1
C          j = 1
C          if (ex.eq.1 .and. ey.eq.1) then
C             do k=1,nz1
C                ua(k,ez) = u(i,j,k,e)
C             enddo
C          endif
C       enddo

C       call gop(ua,w2,'+  ',mz)
 
C       return
C       end

c     ############################################################
      subroutine output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl
     $                           ,nel_slab,z_inflow)
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z_inflow
      integer nel_slab

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)

      character*80 istepc_inflow,icfile_inflow
c    ----------------------------------------------------------

      if (nid.eq.0) then
        write(istepc_inflow,'(i32)') istep
        istepc_inflow=adjustl(istepc_inflow)
        icfile_inflow=trim('inflow2d'//'.'//trim(istepc_inflow))
        open(unit=58,file=icfile_inflow,access='stream',
     &     form='unformatted')
        write(58) z_inflow
        write(58) vxin_pl,vyin_pl,vzin_pl,tin_pl
        close(58)
      endif

      return
      end
c----------------------------------------------------------------------

      subroutine read_inflow(vxin,vyin,vzin,tin,nelin,nin)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelin,nin

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)


      real dum(nx1,ny1,nz1,nelin)
      character*80 icfile
c     -----------------------------------------------------

      call rzero(vxin,nin)
      call rzero(vyin,nin)
      call rzero(vzin,nin)
      call rzero(tin,nin)

c      Zero all dummy arrays
       call rzero(dum,nin)
       call rzero(vxin,nin)
       call rzero(vyin,nin)
       call rzero(vzin,nin)
       call rzero(tin,nin)
c      Read IC file
      if (nid.eq.0) then
         icfile=trim('vx_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vxin
         close(58)
         icfile=trim('vy_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vyin
         close(58)
         icfile=trim('vz_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vzin
         close(58)
         icfile=trim('temp_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) tin
         close(58)
      endif
c     Add through all processors  
      call gop(vxin,dum,'+  ',nin)
      call gop(vyin,dum,'+  ',nin)
      call gop(vzin,dum,'+  ',nin)
      call gop(tin,dum,'+  ',nin)

      return
      end

c-----------------------------------------------------------------------
      subroutine planar_average_z(ua,u,w1,w2)
c
c     Compute r-s planar average of quantity u() USED IN INTERPOLATE INFLOW
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nz1,nelz),u(nx1*ny1,nz1,nelv),w1(nz1,nelz),w2(nz1,nelz)
      integer e,eg,ez
c
      melxy = nelx*nely
c
      nz = nz1*nelz
      call rzero(ua,nz)
      call rzero(w1,nz)
c
      do e=1,nelt
c
         eg = lglel(e)
         ez = 1 + (eg-1)/melxy
c
         do k=1,nz1
         do i=1,nx1*ny1
            zz = (1.-zgm1(k,3))/2.  ! = 1 for k=1, = 0 for k=nz1
            aa = zz*area(i,1,5,e) + (1-zz)*area(i,1,6,e)  ! wgtd jacobian
            w1(k,ez) = w1(k,ez) + aa
            ua(k,ez) = ua(k,ez) + aa*u(i,k,e)
         enddo
         enddo
      enddo
c
      call gop(ua,w2,'+  ',nz)
      call gop(w1,w2,'+  ',nz)
c
      do i=1,nz
         ua(i,1) = ua(i,1) / w1(i,1)   ! Normalize
      enddo
c
      return
      end

       subroutine output_means(atime,timel,dtime,w4)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real atime,timel,dtime
       character*80 icfile,istepc
       real w4(ly1,lz1,lely,lelz)

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


       m=ny1*nz1*lely*lelz
       if(nid.eq.0) then
          write(*,*)'*********Writing statistics.......*********'
          write(istepc,'(i32)') istep
          istepc=adjustl(istepc)
          icfile=trim('means.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) time,atime,timel,dtime
          write(58) int(nx1),int(lelx),int(lely),int(lelz)
          do i=1,4
            call copy(w4,summ_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su2m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          do i=1,6
            call copy(w4,suvm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,suxm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,sux2_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su3m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
         do i=1,6
            call copy(w4,sv2u_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
         do i=1,4
            call copy(w4,spmm_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          close(58)
       endif
       return
       end


      subroutine input_means()
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real w4(ly1,lz1,lely,lelz)
      integer dumm

      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)
     & , su3m_2d_o(lx1,ly1,lz1,lelt,4)
     & , sv2u_2d_o(lx1,ly1,lz1,lelt,6)
     & , spmm_2d_o(lx1,ly1,lz1,lelt,4)
     & ,timem,atimem,timelm,dtimem,t_tot

      m=ny1*nz1*lely*lelz

      call rzero(summ_2d_o,size(summ_2d_o))
      call rzero(su2m_2d_o,size(su2m_2d_o))
      call rzero(suvm_2d_o,size(suvm_2d_o))
      call rzero(suxm_2d_o,size(suxm_2d_o))
      call rzero(sux2_2d_o,size(sux2_2d_o))
      call rzero(su3m_2d_o,size(su3m_2d_o))
      call rzero(sv2u_2d_o,size(sv2u_2d_o))
      call rzero(spmm_2d_o,size(spmm_2d_o))

      if (nid.eq.0) then
         write(*,*)'*********Reading means file: means.ini....*********'
         open(unit=58,file='means.ini',access='stream',
     &     form='unformatted')
         read(58) timem,atimem,timelm,dtimem
         read(58) dumm,dumm,dumm,dumm
         do i=1,4
          read(58) w4
          call copy(summ_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
          read(58) w4
          call copy(su2m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
          read(58) w4
          call copy(suvm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(suxm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(sux2_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
            read(58) w4
            call copy(su3m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
            read(58) w4
            call copy(sv2u_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
            read(58) w4
            call copy(spmm_2d_o(1,1,1,1,i),w4,m)
         enddo
         close(58)
       endif
C       do i=1,4
C           call gop(summ_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,4
C           call gop(su2m_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,6
C           call gop(suvm_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,12
C           call gop(suxm_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,12
C           call gop(sux2_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,4
C           call gop(su3m_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,6
C           call gop(sv2u_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
C       do i=1,4
C           call gop(spmm_2d_o(1,1,1,1,i),w4,'+  ',m)
C       enddo
      return
      end

      subroutine print_yz_mesh

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real ymm(ly1,lz1,lely,lelz),zmm(ly1,lz1,lely,lelz)

c     xmm --> yz slice; ymm --> xz slice; zmm --> xy slice  

      real w1(ly1,lz1,lely,lelz),w2(ly1,lz1,lely,lelz)


      call x_slice(ymm,ym1,w1,w2)
      call x_slice(zmm,zm1,w1,w2)

      if(nid.eq.0) then
          write(*,*)'*********Writing y-z plane mesh.......*********'
          write(istepc,'(i32)') istep
          open(unit=58,file='yzmesh.dat',
     &       access='stream',form='unformatted')
          write(58)ly1,lz1,lely,lelz
          write(58)ymm,zmm
          close(58)
      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine outfld2d_yz(z,y,w,v,tt,ny,nz,nly,nlz,name,ifld)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z(ny,nz,nly,nlz)
      real y(ny,nz,nly,nlz)
      real v(ny,nz,nly,nlz)
      real w(ny,nz,nly,nlz)
      real tt(ny,nz,nly,nlz)
      character*3 name

      character*2  excode(15)
      character*12 fm
      character*20 outfile

c     if (istep.le.10) write(6,*) nid,' in out2d:',iz

      call blank(excode,30)
c
      excode(1) = 'X '
      excode(2) = 'Y '
      excode(3) = 'U '
c     excode(4) = 'V '
c     excode(5) = 'P '
c     excode(6) = 'T '
c
      excode(4) = '  '
      excode(5) = 'T '
C       excode(6) = 'T '
      nthings   =  6

      ierr = 0 
      if (nid.eq.0) then
         write(*,*)'******Writing spanwise-averaged fld file....*******'
         call blank(outfile,20)
         if (ifld.lt.100) then
            write(outfile,2) name,ifld
    2       format(a3,'2d.fld',i2.2)
         elseif (ifld.lt.1000) then
            write(outfile,3) name,ifld
    3       format(a3,'2d.fld',i3)
         elseif (ifld.lt.10000) then
            write(outfile,4) name,ifld
    4       format(a3,'2d.fld',i4)
         elseif (ifld.lt.100000) then
            write(outfile,5) name,ifld
    5       format(a3,'2d.fld',i5)
         elseif (ifld.lt.1000000) then
            write(outfile,6) name,ifld
    6       format(a3,'2d.fld',i6)
         endif
         open(unit=24,file=outfile,status='unknown')
         call dump_header2d(excode,ny,nz,nly,nlz,ierr)

         n = ny*nz*nly*nlz
c        write(6,*) fm
c        call exitt
C          write(24,fm) (z(i),y(i),u(i),v(i),w(i),t(i),i=1,n)

          do l=1,nlz
             do k=1,nly
                 do j=1,nz
                   do i=1,ny
                     write(24,'(1p5e14.6)') z(i,j,k,l),y(i,j,k,l),
     &                   w(i,j,k,l),v(i,j,k,l),tt(i,j,k,l)
                   enddo
                 enddo
              enddo
          enddo
c  10    format('''(1p',i1,'e15.7)''')
c  10    format(1p7e15.7)
c
         close(24)
      endif
      call err_chk(ierr,'Error using byte_write,outfld2d. Abort.$')

      return
      end

      subroutine spline(x,y,n,y2,u)
C       parameter (nmax=10000000)
C       dimension x(n),y(n),y2(n),u(n)
      real x(n),y(n),y2(n),u(n)
C       if (n.gt.nmax) then
C          write(6,11) n,nmax
C    11    FORMAT(2X,'ERROR:  Attempt to fit a spline with',I5
C      $            ,'greater than',I4,' points.'
C      $       ,/,2X,'Recompile routine SPLINE.')
C          call exitti('routine spline fail$',n)
C       endif
      y2(1)=0.0
      u(1) =0.0
      do i=2,n-1
         ir=i+1
         il=i-1
         sig=(x(i)-x(il))/(x(ir)-x(il))
         p=sig*y2(il)+2.
         y2(i)=(sig-1.)/p
         u(i)= ( 6.*
     $     ( (y(ir)-y(i))/(x(ir)-x(i))-(y(i)-y(il))/ (x(i)-x(il) ) )
     $            / (x(ir)-x(il))
     $    - sig*u(il) )/p
      enddo
      qn=0.0
      un=0.0
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.)
      do k=n-1,1,-1
         y2(k)=y2(k)*y2(k+1)+u(k)
      enddo
      return
      end

      subroutine splint(xa,ya,y2a,n,x,y)
c     p. 88-89, numerical recipes
      real xa(n),ya(n),y2a(n)
      klo=1
      khi=n
    1   if ((khi-klo).gt.1) then
           k=(khi+klo)/2
           if (xa(k).gt.x) then
              khi=k
           else
              klo=k
           endif
           goto 1
        endif
      h=xa(khi)-xa(klo)
      if (h.eq.0) then
C          write(6,*) xa(khi), 'splint failure',khi
          y=0.0
         return
      endif
      a=(xa(khi)-x)/h
      b=(x-xa(klo))/h
      y=a*ya(klo)+b*ya(khi)+
     $  ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.
      return
      end

      subroutine set_IC(vxin,vyin,vzin,tin,nelin,nelx_in,nely_in,nelz_in
     $                 ,nel_slab,theta)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelx_in,nel_slab,nelin,nely_in,ex,ey,ez,eg,e,nxyz,egchnl
      integer nchnlon,nelz_in,ez1
      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)
      real theta
      character*80 icfile,istepc
      real tmpz,tmpy
c     -----------------------------------------------------
      nxyz = nx1*ny1*nz1
      do i=1,lx1*ly1*lz1*nelin
        tmpz=vzin(i,1,1,1)*cos(theta)+vyin(i,1,1,1)*sin(theta)
        tmpy=vyin(i,1,1,1)*cos(theta)-vzin(i,1,1,1)*sin(theta)
        vzin(i,1,1,1)=tmpz
        vyin(i,1,1,1)=tmpy
      enddo


      do e=1,nelv
        eg = lglel(e)
        call  get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
        if (ey.le.nely_in) then
          if (mod(ez,nelz_in).eq.0) then
            nchnlon = int(ez/nelz_in)
          else
            nchnlon = int(ez/nelz_in)+1
          endif
          ez1 = ez - (nchnlon-1)*nelz_in
          egchnl = nel_slab*(ez1-1)+nelx_in*(ey-1)+ex !Global element number
          call copy(vx(1,1,1,e),vxin(1,1,1,egchnl),nxyz)
          call copy(vy(1,1,1,e),vyin(1,1,1,egchnl),nxyz)
          call copy(vz(1,1,1,e),vzin(1,1,1,egchnl),nxyz)
        endif
      enddo

      do e=1,nelt
        eg = lglel(e)
        call  get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
        if (ey.le.nely_in) then
          if (mod(ez,nelz_in).eq.0) then
            nchnlon = int(ez/nelz_in)
          else
            nchnlon = int(ez/nelz_in)+1
          endif
          ez1 = ez - (nchnlon-1)*nelz_in
          egchnl = nel_slab*(ez1-1)+nelx_in*(ey-1)+ex !Global element number
          call copy(t(1,1,1,e,1),tin(1,1,1,egchnl),nxyz)
        endif
      enddo
      return
      end

      subroutine output_2d(timel,um,vm,tm)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real timel
       real um(ly1,lz1,lely,lelz),vm(ly1,lz1,lely,lelz),
     &      tm(ly1,lz1,lely,lelz)
       character*80 icfile,istepc

       if(nid.eq.0) then
          write(*,*)'******Writing spanwise-averaged file....*******'
          write(istepc,'(i32)') istep
          istepc=adjustl(istepc)
          icfile=trim('2dmeans.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) time
          write(58) int(nx1),int(lelx),int(lely),int(lelz)
          write(58)um
          write(58)vm
          write(58)tm
          close(58)
       endif
       return
       end

      function dongOutflow(ix,iy,iz,iel,iside,u0,delta)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'

      real sn(3)

      ux = vx(ix,iy,iz,iel)
      uy = vy(ix,iy,iz,iel)
      uz = vz(ix,iy,iz,iel)

      call getSnormal(sn,ix,iy,iz,iside,iel)
      vn = ux*sn(1) + uy*sn(2) + uz*sn(3) 
      S0 = 0.5*(1.0 - tanh(vn/u0/delta))

      dongOutflow = -0.5*(ux*ux+uy*uy+uz*uz)*S0

      return
      end
C-----------------------------------------------------------------------
      subroutine vz_outflow(vzout,w)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'

      real vzout(lx1,ly1,lelx,lely),w(lx1,ly1,lelx,lely)
      integer e,eg,ex,ey,ez, m

      m=lx1*ly1*lelx*lely
      call rzero(vzout,m)
      call rzero(w,m)
      do e=1,nelv
        eg = lglel(e)
        call get_exyz(ex,ey,ez,eg,lelx,lely,lelz)
        if (ez.eq.lelz) then
          do j=1,ny1
            do i=1,nx1  
              w(i,j,ex,ey)= vz(i,j,lz1,e)
            enddo
          enddo
        endif
      enddo
      call gop(w,vzout,'+  ',m)

      return 
      end